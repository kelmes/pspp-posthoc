This is pspp.info, produced by makeinfo version 5.2 from pspp.texi.

This manual is for GNU PSPP version 0.10.2, software for statistical
analysis.

   Copyright (C) 1997, 1998, 2004, 2005, 2009, 2012, 2013, 2014, 2016
Free Software Foundation, Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with no Invariant Sections, no Front-Cover Texts, and
     no Back-Cover Texts.  A copy of the license is included in the
     section entitled "GNU Free Documentation License".
INFO-DIR-SECTION Math
START-INFO-DIR-ENTRY
* PSPP: (pspp).             Statistical analysis package.
* PSPPIRE: (pspp).          Graphical user interface to PSPP.
END-INFO-DIR-ENTRY

   The authors wish to thank Network Theory Ltd
<http://www.network-theory.co.uk> for their financial support in the
production of this manual.


File: pspp.info,  Node: Top,  Next: Introduction,  Up: (dir)

GNU PSPP
********

This manual is for GNU PSPP version 0.10.2, software for statistical
analysis.

   Copyright (C) 1997, 1998, 2004, 2005, 2009, 2012, 2013, 2014, 2016
Free Software Foundation, Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with no Invariant Sections, no Front-Cover Texts, and
     no Back-Cover Texts.  A copy of the license is included in the
     section entitled "GNU Free Documentation License".

* Menu:

* Introduction::                Description of the package.
* License::                     Your rights and obligations.

* Invoking PSPP::               Starting the PSPP text-based interface.
* Invoking PSPPIRE::            Starting the PSPP graphical user interface.
* Using PSPP::                  How to use PSPP -- A brief tutorial.
* Language::                    Basics of the PSPP command language.
* Expressions::                 Numeric and string expression syntax.

* Data Input and Output::       Reading data from user files.
* System and Portable File IO:: Reading and writing system & portable files.
* Combining Data Files::        Combining data from multiple files.
* Variable Attributes::         Adjusting and examining variables.
* Data Manipulation::           Simple operations on data.
* Data Selection::              Select certain cases for analysis.
* Conditionals and Looping::    Doing things many times or not at all.
* Statistics::                  Basic statistical procedures.
* Utilities::                   Other commands.

* Invoking pspp-convert::       Utility for converting among file formats.
* Invoking pspp-dump-sav::      Utility for examining raw .sav files.
* Not Implemented::             What's not here yet
* Bugs::                        Known problems; submitting bug reports.

* Function Index::              Index of PSPP functions for expressions.
* Command Index::               Index of PSPP procedures.
* Concept Index::               Index of concepts.

* GNU Free Documentation License:: License for copying this manual.


File: pspp.info,  Node: Introduction,  Next: License,  Prev: Top,  Up: Top

1 Introduction
**************

PSPP is a tool for statistical analysis of sampled data.  It reads the
data, analyzes the data according to commands provided, and writes the
results to a listing file, to the standard output or to a window of the
graphical display.

   The language accepted by PSPP is similar to those accepted by SPSS
statistical products.  The details of PSPP's language are given later in
this manual.

   PSPP produces tables and charts as output, which it can produce in
several formats; currently, ASCII, PostScript, PDF, HTML, and DocBook
are supported.

   The current version of PSPP, 0.10.2, is incomplete in terms of its
statistical procedure support.  PSPP is a work in progress.  The authors
hope to fully support all features in the products that PSPP replaces,
eventually.  The authors welcome questions, comments, donations, and
code submissions.  *Note Submitting Bug Reports: Bugs, for instructions
on contacting the authors.


File: pspp.info,  Node: License,  Next: Invoking PSPP,  Prev: Introduction,  Up: Top

2 Your rights and obligations
*****************************

PSPP is not in the public domain.  It is copyrighted and there are
restrictions on its distribution, but these restrictions are designed to
permit everything that a good cooperating citizen would want to do.
What is not allowed is to try to prevent others from further sharing any
version of this program that they might get from you.

   Specifically, we want to make sure that you have the right to give
away copies of PSPP, that you receive source code or else can get it if
you want it, that you can change these programs or use pieces of them in
new free programs, and that you know you can do these things.

   To make sure that everyone has such rights, we have to forbid you to
deprive anyone else of these rights.  For example, if you distribute
copies of PSPP, you must give the recipients all the rights that you
have.  You must make sure that they, too, receive or can get the source
code.  And you must tell them their rights.

   Also, for our own protection, we must make certain that everyone
finds out that there is no warranty for PSPP.  If these programs are
modified by someone else and passed on, we want their recipients to know
that what they have is not what we distributed, so that any problems
introduced by others will not reflect on our reputation.

   Finally, any free program is threatened constantly by software
patents.  We wish to avoid the danger that redistributors of a free
program will individually obtain patent licenses, in effect making the
program proprietary.  To prevent this, we have made it clear that any
patent must be licensed for everyone's free use or not licensed at all.

   The precise conditions of the license for PSPP are found in the GNU
General Public License.  You should have received a copy of the GNU
General Public License along with this program; if not, write to the
Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
MA 02110-1301 USA. This manual specifically is covered by the GNU Free
Documentation License (*note GNU Free Documentation License::).


File: pspp.info,  Node: Invoking PSPP,  Next: Invoking PSPPIRE,  Prev: License,  Up: Top

3 Invoking 'pspp'
*****************

PSPP has two separate user interfaces.  This chapter describes 'pspp',
PSPP's command-line driven text-based user interface.  The following
chapter briefly describes PSPPIRE, the graphical user interface to PSPP.

   The sections below describe the 'pspp' program's command-line
interface.

* Menu:

* Main Options::                
* PDF PostScript and SVG Output Options::  
* Plain Text Output Options::   
* HTML Output Options::         
* OpenDocument Output Options::  
* Comma-Separated Value Output Options::  


File: pspp.info,  Node: Main Options,  Next: PDF PostScript and SVG Output Options,  Up: Invoking PSPP

3.1 Main Options
================

Here is a summary of all the options, grouped by type, followed by
explanations in the same order.

   In the table, arguments to long options also apply to any
corresponding short options.

_Non-option arguments_
          SYNTAX-FILE

_Output options_
          -o, --output=OUTPUT-FILE
          -O OPTION=VALUE
          -O format=FORMAT
          -O device={terminal|listing}
          --no-output
          -e, --error-file=ERROR-FILE

_Language options_
          -I, --include=DIR
          -I-, --no-include
          -b, --batch
          -i, --interactive
          -r, --no-statrc
          -a, --algorithm={compatible|enhanced}
          -x, --syntax={compatible|enhanced}
          --syntax-encoding=ENCODING

_Informational options_
          -h, --help
          -V, --version

_Other options_
          -s, --safer
          --testing-mode

SYNTAX-FILE
     Read and execute the named syntax file.  If no syntax files are
     specified, PSPP prompts for commands.  If any syntax files are
     specified, PSPP by default exits after it runs them, but you may
     make it prompt for commands by specifying '-' as an additional
     syntax file.

'-o OUTPUT-FILE'
     Write output to OUTPUT-FILE.  PSPP has several different output
     drivers that support output in various formats (use '--help' to
     list the available formats).  Specify this option more than once to
     produce multiple output files, presumably in different formats.

     Use '-' as OUTPUT-FILE to write output to standard output.

     If no '-o' option is used, then PSPP writes text and CSV output to
     standard output and other kinds of output to whose name is based on
     the format, e.g. 'pspp.pdf' for PDF output.

'-O OPTION=VALUE'
     Sets an option for the output file configured by a preceding '-o'.
     Most options are specific to particular output formats.  A few
     options that apply generically are listed below.

'-O format=FORMAT'
     PSPP uses the extension of the file name given on '-o' to select an
     output format.  Use this option to override this choice by
     specifying an alternate format, e.g. '-o pspp.out -O html' to write
     HTML to a file named 'pspp.out'.  Use '--help' to list the
     available formats.

'-O device={terminal|listing}'
     Sets whether PSPP considers the output device configured by the
     preceding '-o' to be a terminal or a listing device.  This affects
     what output will be sent to the device, as configured by the SET
     command's output routing subcommands (*note SET::).  By default,
     output written to standard output is considered a terminal device
     and other output is considered a listing device.

'--no-output'
     Disables output entirely, if neither '-o' nor '-O' is also used.
     If one of those options is used, '--no-output' has no effect.

'-e ERROR-FILE'
'--error-file=ERROR-FILE'
     Configures a file to receive PSPP error, warning, and note messages
     in plain text format.  Use '-' as ERROR-FILE to write messages to
     standard output.  The default error file is standard output in the
     absence of these options, but this is suppressed if an output
     device writes to standard output (or another terminal), to avoid
     printing every message twice.  Use 'none' as ERROR-FILE to
     explicitly suppress the default.

'-I DIR'
'--include=DIR'
     Appends DIR to the set of directories searched by the 'INCLUDE'
     (*note INCLUDE::) and 'INSERT' (*note INSERT::) commands.

'-I-'
'--no-include'
     Clears all directories from the include path, including directories
     inserted in the include path by default.  The default include path
     is '.' (the current directory), followed by '.pspp' in the user's
     home directory, followed by PSPP's system configuration directory
     (usually '/etc/pspp' or '/usr/local/etc/pspp').

'-b'
'--batch'
'-i'
'--interactive'
     These options forces syntax files to be interpreted in batch mode
     or interactive mode, respectively, rather than the default "auto"
     mode.  *Note Syntax Variants::, for a description of the
     differences.

'-r'
'--no-statrc'
     Disables running 'rc' at PSPP startup time.

'-a {enhanced|compatible}'
'--algorithm={enhanced|compatible}'
     With 'enhanced', the default, PSPP uses the best implemented
     algorithms for statistical procedures.  With 'compatible', however,
     PSPP will in some cases use inferior algorithms to produce the same
     results as the proprietary program SPSS.

     Some commands have subcommands that override this setting on a per
     command basis.

'-x {enhanced|compatible}'
'--syntax={enhanced|compatible}'
     With 'enhanced', the default, PSPP accepts its own extensions
     beyond those compatible with the proprietary program SPSS. With
     'compatible', PSPP rejects syntax that uses these extensions.

'--syntax-encoding=ENCODING'
     Specifies ENCODING as the encoding for syntax files named on the
     command line.  The ENCODING also becomes the default encoding for
     other syntax files read during the PSPP session by the 'INCLUDE'
     and 'INSERT' commands.  *Note INSERT::, for the accepted forms of
     ENCODING.

'--help'
     Prints a message describing PSPP command-line syntax and the
     available device formats, then exits.

'-V'
'--version'
     Prints a brief message listing PSPP's version, warranties you don't
     have, copying conditions and copyright, and e-mail address for bug
     reports, then exits.

'-s'
'--safer'
     Disables certain unsafe operations.  This includes the 'ERASE' and
     'HOST' commands, as well as use of pipes as input and output files.

'--testing-mode'
     Invoke heuristics to assist with testing PSPP.  For use by 'make
     check' and similar scripts.


File: pspp.info,  Node: PDF PostScript and SVG Output Options,  Next: Plain Text Output Options,  Prev: Main Options,  Up: Invoking PSPP

3.2 PDF, PostScript, and SVG Output Options
===========================================

To produce output in PDF, PostScript, and SVG formats, specify '-o FILE'
on the PSPP command line, optionally followed by any of the options
shown in the table below to customize the output format.

   PDF, PostScript, and SVG output is only available if your
installation of PSPP was compiled with the Cairo library.

'-O format={pdf|ps|svg}'
     Specify the output format.  This is only necessary if the file name
     given on '-o' does not end in '.pdf', '.ps', or '.svg'.

'-O paper-size=PAPER-SIZE'
     Paper size, as a name (e.g. 'a4', 'letter') or measurements (e.g.
     '210x297', '8.5x11in').

     The default paper size is taken from the 'PAPERSIZE' environment
     variable or the file indicated by the 'PAPERCONF' environment
     variable, if either variable is set.  If not, and your system
     supports the 'LC_PAPER' locale category, then the default paper
     size is taken from the locale.  Otherwise, if '/etc/papersize'
     exists, the default paper size is read from it.  As a last resort,
     A4 paper is assumed.

'-O foreground-color=COLOR'
'-O background-color=COLOR'
     Sets COLOR as the color to be used for the background or
     foreground.  Color should be given in the format '#RRRRGGGGBBBB',
     where RRRR, GGGG and BBBB are 4 character hexadecimal
     representations of the red, green and blue components respectively.

'-O orientation=ORIENTATION'
     Either 'portrait' or 'landscape'.  Default: 'portrait'.

'-O left-margin=DIMENSION'
'-O right-margin=DIMENSION'
'-O top-margin=DIMENSION'
'-O bottom-margin=DIMENSION'
     Sets the margins around the page.  See below for the allowed forms
     of DIMENSION Default: '0.5in'.

'-O prop-font=FONT-NAME'
'-O emph-font=FONT-NAME'
'-O fixed-font=FONT-NAME'
     Sets the font used for proportional, emphasized, or fixed-pitch
     text.  Most systems support CSS-like font names such as "serif" and
     "monospace", but a wide range of system-specific font are likely to
     be supported as well.

     Default: proportional font 'serif', emphasis font 'serif italic',
     fixed-pitch font 'monospace'.

'-O font-size=FONT-SIZE'
     Sets the size of the default fonts, in thousandths of a point.
     Default: 10000 (10 point).

'-O line-gutter=DIMENSION'
     Sets the width of white space on either side of lines that border
     text or graphics objects.  Default: '1pt'.

'-O line-spacing=DIMENSION'
     Sets the spacing between the lines in a double line in a table.
     Default: '1pt'.

'-O line-width=DIMENSION'
     Sets the width of the lines used in tables.  Default: '0.5pt'.

   Each DIMENSION value above may be specified in various units based on
its suffix: 'mm' for millimeters, 'in' for inches, or 'pt' for points.
Lacking a suffix, numbers below 50 are assumed to be in inches and those
about 50 are assumed to be in millimeters.


File: pspp.info,  Node: Plain Text Output Options,  Next: HTML Output Options,  Prev: PDF PostScript and SVG Output Options,  Up: Invoking PSPP

3.3 Plain Text Output Options
=============================

PSPP can produce plain text output, drawing boxes using ASCII or Unicode
line drawing characters.  To produce plain text output, specify '-o
FILE' on the PSPP command line, optionally followed by options from the
table below to customize the output format.

   Plain text output is encoded in UTF-8.

'-O format=txt'
     Specify the output format.  This is only necessary if the file name
     given on '-o' does not end in '.txt' or '.list'.

'-O charts={TEMPLATE.png|none}'
     Name for chart files included in output.  The value should be a
     file name that includes a single '#' and ends in 'png'.  When a
     chart is output, the '#' is replaced by the chart number.  The
     default is the file name specified on '-o' with the extension
     stripped off and replaced by '-#.png'.

     Specify 'none' to disable chart output.  Charts are always disabled
     if your installation of PSPP was compiled without the Cairo
     library.

'-O foreground-color=COLOR'
'-O background-color=COLOR'
     Sets COLOR as the color to be used for the background or foreground
     to be used for charts.  Color should be given in the format
     '#RRRRGGGGBBBB', where RRRR, GGGG and BBBB are 4 character
     hexadecimal representations of the red, green and blue components
     respectively.  If charts are disabled, this option has no effect.

'-O paginate=BOOLEAN'
     If set, PSPP writes an ASCII formfeed the end of every page.
     Default: 'off'.

'-O headers=BOOLEAN'
     If enabled, PSPP prints two lines of header information giving
     title and subtitle, page number, date and time, and PSPP version
     are printed at the top of every page.  These two lines are in
     addition to any top margin requested.  Default: 'off'.

'-O length=LINE-COUNT'
     Physical length of a page.  Headers and margins are subtracted from
     this value.  You may specify the number of lines as a number, or
     for screen output you may specify 'auto' to track the height of the
     terminal as it changes.  Default: '66'.

'-O width=CHARACTER-COUNT'
     Width of a page, in characters.  Margins are subtracted from this
     value.  For screen output you may specify 'auto' in place of a
     number to track the width of the terminal as it changes.  Default:
     '79'.

'-O top-margin=TOP-MARGIN-LINES'
     Length of the top margin, in lines.  PSPP subtracts this value from
     the page length.  Default: '0'.

'-O bottom-margin=BOTTOM-MARGIN-LINES'
     Length of the bottom margin, in lines.  PSPP subtracts this value
     from the page length.  Default: '0'.

'-O box={ascii|unicode}'
     Sets the characters used for lines in tables.  If set to 'ascii'
     the characters '-', '|', and '+' for single-width lines and '=' and
     '#' for double-width lines are used.  If set to 'unicode' then
     Unicode box drawing characters will be used.  The default is
     'unicode' if the locale's character encoding is "UTF-8" or 'ascii'
     otherwise.

'-O emphasis={none|bold|underline}'
     How to emphasize text.  Bold and underline emphasis are achieved
     with overstriking, which may not be supported by all the software
     to which you might pass the output.  Default: 'none'.


File: pspp.info,  Node: HTML Output Options,  Next: OpenDocument Output Options,  Prev: Plain Text Output Options,  Up: Invoking PSPP

3.4 HTML Output Options
=======================

To produce output in HTML format, specify '-o FILE' on the PSPP command
line, optionally followed by any of the options shown in the table below
to customize the output format.

'-O format=html'
     Specify the output format.  This is only necessary if the file name
     given on '-o' does not end in '.html'.

'-O charts={TEMPLATE.png|none}'
     Sets the name used for chart files.  *Note Plain Text Output
     Options::, for details.

'-O borders=BOOLEAN'
     Decorate the tables with borders.  If set to false, the tables
     produced will have no borders.  The default value is true.

'-O css=BOOLEAN'
     Use cascading style sheets.  Cascading style sheets give an
     improved appearance and can be used to produce pages which fit a
     certain web site's style.  The default value is true.


File: pspp.info,  Node: OpenDocument Output Options,  Next: Comma-Separated Value Output Options,  Prev: HTML Output Options,  Up: Invoking PSPP

3.5 OpenDocument Output Options
===============================

To produce output as an OpenDocument text (ODT) document, specify '-o
FILE' on the PSPP command line.  If FILE does not end in '.odt', you
must also specify '-O format=odt'.

   ODT support is only available if your installation of PSPP was
compiled with the libxml2 library.

   The OpenDocument output format does not have any configurable
options.


File: pspp.info,  Node: Comma-Separated Value Output Options,  Prev: OpenDocument Output Options,  Up: Invoking PSPP

3.6 Comma-Separated Value Output Options
========================================

To produce output in comma-separated value (CSV) format, specify '-o
FILE' on the PSPP command line, optionally followed by any of the
options shown in the table below to customize the output format.

'-O format=csv'
     Specify the output format.  This is only necessary if the file name
     given on '-o' does not end in '.csv'.

'-O separator=FIELD-SEPARATOR'
     Sets the character used to separate fields.  Default: a comma
     (',').

'-O quote=QUALIFIER'
     Sets QUALIFIER as the character used to quote fields that contain
     white space, the separator (or any of the characters in the
     separator, if it contains more than one character), or the quote
     character itself.  If QUALIFIER is longer than one character, only
     the first character is used; if QUALIFIER is the empty string, then
     fields are never quoted.

'-O titles=BOOLEAN'
     Whether table titles (brief descriptions) should be printed.
     Default: 'on'.

'-O captions=BOOLEAN'
     Whether table captions (more extensive descriptions) should be
     printed.  Default: on.

   The CSV format used is an extension to that specified in RFC 4180:

Tables
     Each table row is output on a separate line, and each column is
     output as a field.  The contents of a cell that spans multiple rows
     or columns is output only for the top-left row and column; the rest
     are output as empty fields.

Titles
     When a table has a title and titles are enabled, the title is
     output just above the table as a single field prefixed by 'Table:'.

Captions
     When a table has a caption and captions are enabled, the caption is
     output just below the table as a single field prefixed by
     'Caption:'.

Footnotes
     Within a table, footnote markers are output as bracketed letters
     following the cell's contents, e.g. '[a]', '[b]', ...  The
     footnotes themselves are output following the body of the table, as
     a separate two-column table introduced with a line that says
     'Footnotes:'.  Each row in the table represent one footnote: the
     first column is the marker, the second column is the text.

Text
     Text in output is printed as a field on a line by itself.  The
     TITLE and SUBTITLE produce similar output, prefixed by 'Title:' or
     'Subtitle:', respectively.

Messages
     Errors, warnings, and notes are printed the same way as text.

Charts
     Charts are not included in CSV output.

   Successive output items are separated by a blank line.


File: pspp.info,  Node: Invoking PSPPIRE,  Next: Using PSPP,  Prev: Invoking PSPP,  Up: Top

4 Invoking 'psppire'
********************

4.1 The graphic user interface
==============================

The PSPPIRE graphic user interface for PSPP can perform all
functionality of the command line interface.  In addition it gives an
instantaneous view of the data, variables and statistical output.

   The graphic user interface can be started by typing 'psppire' at a
command prompt.  Alternatively many systems have a system of interactive
menus or buttons from which 'psppire' can be started by a series of
mouse clicks.

   Once the principles of the PSPP system are understood, the graphic
user interface is designed to be largely intuitive, and for this reason
is covered only very briefly by this manual.


File: pspp.info,  Node: Using PSPP,  Next: Language,  Prev: Invoking PSPPIRE,  Up: Top

5 Using PSPP
************

PSPP is a tool for the statistical analysis of sampled data.  You can
use it to discover patterns in the data, to explain differences in one
subset of data in terms of another subset and to find out whether
certain beliefs about the data are justified.  This chapter does not
attempt to introduce the theory behind the statistical analysis, but it
shows how such analysis can be performed using PSPP.

   For the purposes of this tutorial, it is assumed that you are using
PSPP in its interactive mode from the command line.  However, the
example commands can also be typed into a file and executed in a
post-hoc mode by typing 'pspp FILENAME' at a shell prompt, where
FILENAME is the name of the file containing the commands.
Alternatively, from the graphical interface, you can select File -> New
-> Syntax to open a new syntax window and use the Run menu when a syntax
fragment is ready to be executed.  Whichever method you choose, the
syntax is identical.

   When using the interactive method, PSPP tells you that it's waiting
for your data with a string like PSPP> or data>.  In the examples of
this chapter, whenever you see text like this, it indicates the prompt
displayed by PSPP, _not_ something that you should type.

   Throughout this chapter reference is made to a number of sample data
files.  So that you can try the examples for yourself, you should have
received these files along with your copy of PSPP.(1)
     *Please note:* Normally these files are installed in the directory
     '/usr/local/share/pspp/examples'.  If however your system
     administrator or operating system vendor has chosen to install them
     in a different location, you will have to adjust the examples
     accordingly.

* Menu:

* Preparation of Data Files::   
* Data Screening and Transformation::  
* Hypothesis Testing::          

   ---------- Footnotes ----------

   (1) These files contain purely fictitious data.  They should not be
used for research purposes.


File: pspp.info,  Node: Preparation of Data Files,  Next: Data Screening and Transformation,  Up: Using PSPP

5.1 Preparation of Data Files
=============================

Before analysis can commence, the data must be loaded into PSPP and
arranged such that both PSPP and humans can understand what the data
represents.  There are two aspects of data:

   * The variables -- these are the parameters of a quantity which has
     been measured or estimated in some way.  For example height, weight
     and geographic location are all variables.
   * The observations (also called 'cases') of the variables -- each
     observation represents an instance when the variables were measured
     or observed.

For example, a data set which has the variables HEIGHT, WEIGHT, and
NAME, might have the observations:
     1881 89.2 Ahmed
     1192 107.01 Frank
     1230 67 Julie
The following sections explain how to define a dataset.

* Menu:

* Defining Variables::          
* Listing the data::            
* Reading data from a text file::  
* Reading data from a pre-prepared PSPP file::  
* Saving data to a PSPP file.::  
* Reading data from other sources::  
* Exiting PSPP::


File: pspp.info,  Node: Defining Variables,  Next: Listing the data,  Up: Preparation of Data Files

5.1.1 Defining Variables
------------------------

Variables come in two basic types, viz: "numeric" and "string".
Variables such as age, height and satisfaction are numeric, whereas name
is a string variable.  String variables are best reserved for commentary
data to assist the human observer.  However they can also be used for
nominal or categorical data.

   *note Example 5.1: data-list. defines two variables FORENAME and
HEIGHT, and reads data into them by manual input.

     PSPP> data list list /forename (A12) height.
     PSPP> begin data.
     data> Ahmed 188
     data> Bertram 167
     data> Catherine 134.231
     data> David 109.1
     data> end data
     PSPP>

Example 5.1: Manual entry of data using the 'DATA LIST' command.  Two
variables FORENAME and HEIGHT are defined and subsequently filled with
manually entered data.

   There are several things to note about this example.

   * The words 'data list list' are an example of the 'DATA LIST'
     command.  *Note DATA LIST::.  It tells PSPP to prepare for reading
     data.  The word 'list' intentionally appears twice.  The first
     occurrence is part of the 'DATA LIST' call, whilst the second tells
     PSPP that the data is to be read as free format data with one
     record per line.

   * The '/' character is important.  It marks the start of the list of
     variables which you wish to define.

   * The text 'forename' is the name of the first variable, and '(A12)'
     says that the variable FORENAME is a string variable and that its
     maximum length is 12 bytes.  The second variable's name is
     specified by the text 'height'.  Since no format is given, this
     variable has the default format.  Normally the default format
     expects numeric data, which should be entered in the locale of the
     operating system.  Thus, the example is correct for English locales
     and other locales which use a period ('.') as the decimal
     separator.  However if you are using a system with a locale which
     uses the comma (',') as the decimal separator, then you should in
     the subsequent lines substitute '.' with ','.  Alternatively, you
     could explicitly tell PSPP that the HEIGHT variable is to be read
     using a period as its decimal separator by appending the text
     'DOT8.3' after the word 'height'.  For more information on data
     formats, *note Input and Output Formats::.

   * Normally, PSPP displays the prompt PSPP> whenever it's expecting a
     command.  However, when it's expecting data, the prompt changes to
     data> so that you know to enter data and not a command.

   * At the end of every command there is a terminating '.' which tells
     PSPP that the end of a command has been encountered.  You should
     not enter '.' when data is expected (ie.  when the data> prompt is
     current) since it is appropriate only for terminating commands.


File: pspp.info,  Node: Listing the data,  Next: Reading data from a text file,  Prev: Defining Variables,  Up: Preparation of Data Files

5.1.2 Listing the data
----------------------

Once the data has been entered, you could type
     PSPP> list /format=numbered.
to list the data.  The optional text '/format=numbered' requests the
case numbers to be shown along with the data.  It should show the
following output:
     Case#     forename   height
     ----- ------------ --------
         1 Ahmed          188.00
         2 Bertram        167.00
         3 Catherine      134.23
         4 David          109.10
Note that the numeric variable HEIGHT is displayed to 2 decimal places,
because the format for that variable is 'F8.2'.  For a complete
description of the 'LIST' command, *note LIST::.


File: pspp.info,  Node: Reading data from a text file,  Next: Reading data from a pre-prepared PSPP file,  Prev: Listing the data,  Up: Preparation of Data Files

5.1.3 Reading data from a text file
-----------------------------------

The previous example showed how to define a set of variables and to
manually enter the data for those variables.  Manual entering of data is
tedious work, and often a file containing the data will be have been
previously prepared.  Let us assume that you have a file called
'mydata.dat' containing the ascii encoded data:
     Ahmed          188.00
     Bertram        167.00
     Catherine      134.23
     David          109.10
                   .
                   .
                   .
     Zachariah      113.02
You can can tell the 'DATA LIST' command to read the data directly from
this file instead of by manual entry, with a command like:
     PSPP> data list file='mydata.dat' list /forename (A12) height.
Notice however, that it is still necessary to specify the names of the
variables and their formats, since this information is not contained in
the file.  It is also possible to specify the file's character encoding
and other parameters.  For full details refer to *note DATA LIST::.


File: pspp.info,  Node: Reading data from a pre-prepared PSPP file,  Next: Saving data to a PSPP file.,  Prev: Reading data from a text file,  Up: Preparation of Data Files

5.1.4 Reading data from a pre-prepared PSPP file
------------------------------------------------

When working with other PSPP users, or users of other software which
uses the PSPP data format, you may be given the data in a pre-prepared
PSPP file.  Such files contain not only the data, but the variable
definitions, along with their formats, labels and other meta-data.
Conventionally, these files (sometimes called "system" files) have the
suffix '.sav', but that is not mandatory.  The following syntax loads a
file called 'my-file.sav'.
     PSPP> get file='my-file.sav'.
You will encounter several instances of this in future examples.


File: pspp.info,  Node: Saving data to a PSPP file.,  Next: Reading data from other sources,  Prev: Reading data from a pre-prepared PSPP file,  Up: Preparation of Data Files

5.1.5 Saving data to a PSPP file.
---------------------------------

If you want to save your data, along with the variable definitions so
that you or other PSPP users can use it later, you can do this with the
'SAVE' command.

   The following syntax will save the existing data and variables to a
file called 'my-new-file.sav'.
     PSPP> save outfile='my-new-file.sav'.
If 'my-new-file.sav' already exists, then it will be overwritten.
Otherwise it will be created.


File: pspp.info,  Node: Reading data from other sources,  Next: Exiting PSPP,  Prev: Saving data to a PSPP file.,  Up: Preparation of Data Files

5.1.6 Reading data from other sources
-------------------------------------

Sometimes it's useful to be able to read data from comma separated text,
from spreadsheets, databases or other sources.  In these instances you
should use the 'GET DATA' command (*note GET DATA::).


File: pspp.info,  Node: Exiting PSPP,  Prev: Reading data from other sources,  Up: Preparation of Data Files

5.1.7 Exiting PSPP
------------------

Use the 'FINISH' command to exit PSPP:
     PSPP> finish.


File: pspp.info,  Node: Data Screening and Transformation,  Next: Hypothesis Testing,  Prev: Preparation of Data Files,  Up: Using PSPP

5.2 Data Screening and Transformation
=====================================

Once data has been entered, it is often desirable, or even necessary, to
transform it in some way before performing analysis upon it.  At the
very least, it's good practice to check for errors.

* Menu:

* Identifying incorrect data::  
* Dealing with suspicious data::  
* Inverting negatively coded variables::  
* Testing data consistency::    
* Testing for normality ::      


File: pspp.info,  Node: Identifying incorrect data,  Next: Dealing with suspicious data,  Up: Data Screening and Transformation

5.2.1 Identifying incorrect data
--------------------------------

Data from real sources is rarely error free.  PSPP has a number of
procedures which can be used to help identify data which might be
incorrect.

   The 'DESCRIPTIVES' command (*note DESCRIPTIVES::) is used to generate
simple linear statistics for a dataset.  It is also useful for
identifying potential problems in the data.  The example file
'physiology.sav' contains a number of physiological measurements of a
sample of healthy adults selected at random.  However, the data entry
clerk made a number of mistakes when entering the data.  *note Example
5.2: descriptives. illustrates the use of 'DESCRIPTIVES' to screen this
data and identify the erroneous values.

     PSPP> get file='/usr/local/share/pspp/examples/physiology.sav'.
     PSPP> descriptives sex, weight, height.

Output:
     DESCRIPTIVES.  Valid cases = 40; cases with missing value(s) = 0.
     +--------#--+-------+-------+-------+-------+
     |Variable# N|  Mean |Std Dev|Minimum|Maximum|
     #========#==#=======#=======#=======#=======#
     |sex     #40|    .45|    .50|    .00|   1.00|
     |height  #40|1677.12| 262.87| 179.00|1903.00|
     |weight  #40|  72.12|  26.70| -55.60|  92.07|
     +--------#--+-------+-------+-------+-------+

Example 5.2: Using the 'DESCRIPTIVES' command to display simple summary
information about the data.  In this case, the results show unexpectedly
low values in the Minimum column, suggesting incorrect data entry.

   In the output of *note Example 5.2: descriptives, the most
interesting column is the minimum value.  The WEIGHT variable has a
minimum value of less than zero, which is clearly erroneous.  Similarly,
the HEIGHT variable's minimum value seems to be very low.  In fact, it
is more than 5 standard deviations from the mean, and is a seemingly
bizarre height for an adult person.  We can examine the data in more
detail with the 'EXAMINE' command (*note EXAMINE::):

   In *note Example 5.3: examine. you can see that the lowest value of
HEIGHT is 179 (which we suspect to be erroneous), but the second lowest
is 1598 which we know from the 'DESCRIPTIVES' command is within 1
standard deviation from the mean.  Similarly the WEIGHT variable has a
lowest value which is negative but a plausible value for the second
lowest value.  This suggests that the two extreme values are outliers
and probably represent data entry errors.

[... continue from *note Example 5.2: descriptives.]
     PSPP> examine height, weight /statistics=extreme(3).

Output:
     #===============================#===========#=======#
     #                               #Case Number| Value #
     #===============================#===========#=======#
     #Height in millimetres Highest 1#         14|1903.00#
     #                              2#         15|1884.00#
     #                              3#         12|1801.65#
     #                     ----------#-----------+-------#
     #                       Lowest 1#         30| 179.00#
     #                              2#         31|1598.00#
     #                              3#         28|1601.00#
     #                     ----------#-----------+-------#
     #Weight in kilograms   Highest 1#         13|  92.07#
     #                              2#          5|  92.07#
     #                              3#         17|  91.74#
     #                     ----------#-----------+-------#
     #                       Lowest 1#         38| -55.60#
     #                              2#         39|  54.48#
     #                              3#         33|  55.45#
     #===============================#===========#=======#

Example 5.3: Using the 'EXAMINE' command to see the extremities of the
data for different variables.  Cases 30 and 38 seem to contain values
very much lower than the rest of the data.  They are possibly erroneous.


File: pspp.info,  Node: Dealing with suspicious data,  Next: Inverting negatively coded variables,  Prev: Identifying incorrect data,  Up: Data Screening and Transformation

5.2.2 Dealing with suspicious data
----------------------------------

If possible, suspect data should be checked and re-measured.  However,
this may not always be feasible, in which case the researcher may decide
to disregard these values.  PSPP has a feature whereby data can assume
the special value 'SYSMIS', and will be disregarded in future analysis.
*Note Missing Observations::.  You can set the two suspect values to the
'SYSMIS' value using the 'RECODE' command.
     PSPP> recode height (179 = SYSMIS).
     PSPP> recode weight (LOWEST THRU 0 = SYSMIS).
The first command says that for any observation which has a HEIGHT value
of 179, that value should be changed to the SYSMIS value.  The second
command says that any WEIGHT values of zero or less should be changed to
SYSMIS. From now on, they will be ignored in analysis.  For detailed
information about the 'RECODE' command *note RECODE::.

   If you now re-run the 'DESCRIPTIVES' or 'EXAMINE' commands in *note
Example 5.2: descriptives. and *note Example 5.3: examine. you will see
a data summary with more plausible parameters.  You will also notice
that the data summaries indicate the two missing values.


File: pspp.info,  Node: Inverting negatively coded variables,  Next: Testing data consistency,  Prev: Dealing with suspicious data,  Up: Data Screening and Transformation

5.2.3 Inverting negatively coded variables
------------------------------------------

Data entry errors are not the only reason for wanting to recode data.
The sample file 'hotel.sav' comprises data gathered from a customer
satisfaction survey of clients at a particular hotel.  In *note Example
5.4: reliability, this file is loaded for analysis.  The line 'display
dictionary.' tells PSPP to display the variables and associated data.
The output from this command has been omitted from the example for the
sake of clarity, but you will notice that each of the variables V1, V2
... V5 are measured on a 5 point Likert scale, with 1 meaning "Strongly
disagree" and 5 meaning "Strongly agree".  Whilst variables V1, V2 and
V4 record responses to a positively posed question, variables V3 and V5
are responses to negatively worded questions.  In order to perform
meaningful analysis, we need to recode the variables so that they all
measure in the same direction.  We could use the 'RECODE' command, with
syntax such as:
     recode v3 (1 = 5) (2 = 4) (4 = 2) (5 = 1).
However an easier and more elegant way uses the 'COMPUTE' command (*note
COMPUTE::).  Since the variables are Likert variables in the range (1
... 5), subtracting their value from 6 has the effect of inverting them:
     compute VAR = 6 - VAR.
*note Example 5.4: reliability. uses this technique to recode the
variables V3 and V5.  After applying 'COMPUTE' for both variables, all
subsequent commands will use the inverted values.


File: pspp.info,  Node: Testing data consistency,  Next: Testing for normality,  Prev: Inverting negatively coded variables,  Up: Data Screening and Transformation

5.2.4 Testing data consistency
------------------------------

A sensible check to perform on survey data is the calculation of
reliability.  This gives the statistician some confidence that the
questionnaires have been completed thoughtfully.  If you examine the
labels of variables V1, V3 and V4, you will notice that they ask very
similar questions.  One would therefore expect the values of these
variables (after recoding) to closely follow one another, and we can
test that with the 'RELIABILITY' command (*note RELIABILITY::).  *note
Example 5.4: reliability. shows a PSPP session where the user (after
recoding negatively scaled variables) requests reliability statistics
for V1, V3 and V4.

     PSPP> get file='/usr/local/share/pspp/examples/hotel.sav'.
     PSPP> display dictionary.
     PSPP> * recode negatively worded questions.
     PSPP> compute v3 = 6 - v3.
     PSPP> compute v5 = 6 - v5.
     PSPP> reliability v1, v3, v4.

Output (dictionary information omitted for clarity):
     1.1 RELIABILITY.  Case Processing Summary
     #==============#==#======#
     #              # N|   %  #
     #==============#==#======#
     #Cases Valid   #17|100.00#
     #      Excluded# 0|   .00#
     #      Total   #17|100.00#
     #==============#==#======#

     1.2 RELIABILITY.  Reliability Statistics
     #================#==========#
     #Cronbach's Alpha#N of Items#
     #================#==========#
     #             .81#         3#
     #================#==========#

Example 5.4: Recoding negatively scaled variables, and testing for
reliability with the 'RELIABILITY' command.  The Cronbach Alpha
coefficient suggests a high degree of reliability among variables V1, V3
and V4.

   As a rule of thumb, many statisticians consider a value of Cronbach's
Alpha of 0.7 or higher to indicate reliable data.  Here, the value is
0.81 so the data and the recoding that we performed are vindicated.


File: pspp.info,  Node: Testing for normality,  Prev: Testing data consistency,  Up: Data Screening and Transformation

5.2.5 Testing for normality
---------------------------

Many statistical tests rely upon certain properties of the data.  One
common property, upon which many linear tests depend, is that of
normality -- the data must have been drawn from a normal distribution.
It is necessary then to ensure normality before deciding upon the test
procedure to use.  One way to do this uses the 'EXAMINE' command.

   In *note Example 5.5: normality, a researcher was examining the
failure rates of equipment produced by an engineering company.  The file
'repairs.sav' contains the mean time between failures (MTBF) of some
items of equipment subject to the study.  Before performing linear
analysis on the data, the researcher wanted to ascertain that the data
is normally distributed.

   A normal distribution has a skewness and kurtosis of zero.  Looking
at the skewness of MTBF in *note Example 5.5: normality. it is clear
that the mtbf figures have a lot of positive skew and are therefore not
drawn from a normally distributed variable.  Positive skew can often be
compensated for by applying a logarithmic transformation.  This is done
with the 'COMPUTE' command in the line
     compute mtbf_ln = ln (mtbf).
Rather than redefining the existing variable, this use of 'COMPUTE'
defines a new variable MTBF_LN which is the natural logarithm of MTBF.
The final command in this example calls 'EXAMINE' on this new variable,
and it can be seen from the results that both the skewness and kurtosis
for MTBF_LN are very close to zero.  This provides some confidence that
the MTBF_LN variable is normally distributed and thus safe for linear
analysis.  In the event that no suitable transformation can be found,
then it would be worth considering an appropriate non-parametric test
instead of a linear one.  *Note NPAR TESTS::, for information about
non-parametric tests.

     PSPP> get file='/usr/local/share/pspp/examples/repairs.sav'.
     PSPP> examine mtbf
                     /statistics=descriptives.
     PSPP> compute mtbf_ln = ln (mtbf).
     PSPP> examine mtbf_ln
                     /statistics=descriptives.

Output:
     1.2 EXAMINE.  Descriptives
     #====================================================#=========#==========#
     #                                                    #Statistic|Std. Error#
     #====================================================#=========#==========#
     #mtbf    Mean                                        #   8.32  |   1.62   #
     #        95% Confidence Interval for Mean Lower Bound#   4.85  |          #
     #                                         Upper Bound#  11.79  |          #
     #        5% Trimmed Mean                             #   7.69  |          #
     #        Median                                      #   8.12  |          #
     #        Variance                                    #  39.21  |          #
     #        Std. Deviation                              #   6.26  |          #
     #        Minimum                                     #   1.63  |          #
     #        Maximum                                     #  26.47  |          #
     #        Range                                       #  24.84  |          #
     #        Interquartile Range                         #   5.83  |          #
     #        Skewness                                    #   1.85  |    .58   #
     #        Kurtosis                                    #   4.49  |   1.12   #
     #====================================================#=========#==========#

     2.2 EXAMINE.  Descriptives
     #====================================================#=========#==========#
     #                                                    #Statistic|Std. Error#
     #====================================================#=========#==========#
     #mtbf_ln Mean                                        #   1.88  |    .19   #
     #        95% Confidence Interval for Mean Lower Bound#   1.47  |          #
     #                                         Upper Bound#   2.29  |          #
     #        5% Trimmed Mean                             #   1.88  |          #
     #        Median                                      #   2.09  |          #
     #        Variance                                    #   .54   |          #
     #        Std. Deviation                              #   .74   |          #
     #        Minimum                                     #   .49   |          #
     #        Maximum                                     #   3.28  |          #
     #        Range                                       #   2.79  |          #
     #        Interquartile Range                         #   .92   |          #
     #        Skewness                                    #   -.16  |    .58   #
     #        Kurtosis                                    #   -.09  |   1.12   #
     #====================================================#=========#==========#

Example 5.5: Testing for normality using the 'EXAMINE' command and
applying a logarithmic transformation.  The MTBF variable has a large
positive skew and is therefore unsuitable for linear statistical
analysis.  However the transformed variable (MTBF_LN) is close to normal
and would appear to be more suitable.


File: pspp.info,  Node: Hypothesis Testing,  Prev: Data Screening and Transformation,  Up: Using PSPP

5.3 Hypothesis Testing
======================

One of the most fundamental purposes of statistical analysis is
hypothesis testing.  Researchers commonly need to test hypotheses about
a set of data.  For example, she might want to test whether one set of
data comes from the same distribution as another, or whether the mean of
a dataset significantly differs from a particular value.  This section
presents just some of the possible tests that PSPP offers.

   The researcher starts by making a "null hypothesis".  Often this is a
hypothesis which he suspects to be false.  For example, if he suspects
that A is greater than B he will state the null hypothesis as A = B.(1)

   The "p-value" is a recurring concept in hypothesis testing.  It is
the highest acceptable probability that the evidence implying a null
hypothesis is false, could have been obtained when the null hypothesis
is in fact true.  Note that this is not the same as "the probability of
making an error" nor is it the same as "the probability of rejecting a
hypothesis when it is true".

* Menu:

* Testing for differences of means::  
* Linear Regression::           

   ---------- Footnotes ----------

   (1) This example assumes that it is already proven that B is not
greater than A.


File: pspp.info,  Node: Testing for differences of means,  Next: Linear Regression,  Up: Hypothesis Testing

5.3.1 Testing for differences of means
--------------------------------------

A common statistical test involves hypotheses about means.  The 'T-TEST'
command is used to find out whether or not two separate subsets have the
same mean.

   *note Example 5.6: t-test. uses the file 'physiology.sav' previously
encountered.  A researcher suspected that the heights and core body
temperature of persons might be different depending upon their sex.  To
investigate this, he posed two null hypotheses:
   * The mean heights of males and females in the population are equal.
   * The mean body temperature of males and females in the population
     are equal.
For the purposes of the investigation the researcher decided to use a
p-value of 0.05.

   In addition to the T-test, the 'T-TEST' command also performs the
Levene test for equal variances.  If the variances are equal, then a
more powerful form of the T-test can be used.  However if it is unsafe
to assume equal variances, then an alternative calculation is necessary.
PSPP performs both calculations.

   For the HEIGHT variable, the output shows the significance of the
Levene test to be 0.33 which means there is a 33% probability that the
Levene test produces this outcome when the variances are equal.  Had the
significance been less than 0.05, then it would have been unsafe to
assume that the variances were equal.  However, because the value is
higher than 0.05 the homogeneity of variances assumption is safe and the
"Equal Variances" row (the more powerful test) can be used.  Examining
this row, the two tailed significance for the HEIGHT t-test is less than
0.05, so it is safe to reject the null hypothesis and conclude that the
mean heights of males and females are unequal.

   For the TEMPERATURE variable, the significance of the Levene test is
0.58 so again, it is safe to use the row for equal variances.  The equal
variances row indicates that the two tailed significance for TEMPERATURE
is 0.20.  Since this is greater than 0.05 we must reject the null
hypothesis and conclude that there is insufficient evidence to suggest
that the body temperature of male and female persons are different.

     PSPP> get file='/usr/local/share/pspp/examples/physiology.sav'.
     PSPP> recode height (179 = SYSMIS).
     PSPP> t-test group=sex(0,1) /variables = height temperature.
Output:
     1.1 T-TEST.  Group Statistics
     #==================#==#=======#==============#========#
     #              sex | N|  Mean |Std. Deviation|SE. Mean#
     #==================#==#=======#==============#========#
     #height      Male  |22|1796.49|         49.71|   10.60#
     #            Female|17|1610.77|         25.43|    6.17#
     #temperature Male  |22|  36.68|          1.95|     .42#
     #            Female|18|  37.43|          1.61|     .38#
     #==================#==#=======#==============#========#
     1.2 T-TEST.  Independent Samples Test
     #===========================#=========#===============================   =#
     #                           # Levene's| t-test for Equality of Means      #
     #                           #----+----+------+-----+------+---------+-   -#
     #                           #    |    |      |     |      |         |     #
     #                           #    |    |      |     |Sig. 2|         |     #
     #                           #  F |Sig.|   t  |  df |tailed|Mean Diff|     #
     #===========================#====#====#======#=====#======#=========#=   =#
     #height      Equal variances# .97| .33| 14.02|37.00|   .00|   185.72| ... #
     #          Unequal variances#    |    | 15.15|32.71|   .00|   185.72| ... #
     #temperature Equal variances# .31| .58| -1.31|38.00|   .20|     -.75| ... #
     #          Unequal variances#    |    | -1.33|37.99|   .19|     -.75| ... #
     #===========================#====#====#======#=====#======#=========#=   =#

Example 5.6: The 'T-TEST' command tests for differences of means.  Here,
the HEIGHT variable's two tailed significance is less than 0.05, so the
null hypothesis can be rejected.  Thus, the evidence suggests there is a
difference between the heights of male and female persons.  However the
significance of the test for the TEMPERATURE variable is greater than
0.05 so the null hypothesis cannot be rejected, and there is
insufficient evidence to suggest a difference in body temperature.


File: pspp.info,  Node: Linear Regression,  Prev: Testing for differences of means,  Up: Hypothesis Testing

5.3.2 Linear Regression
-----------------------

Linear regression is a technique used to investigate if and how a
variable is linearly related to others.  If a variable is found to be
linearly related, then this can be used to predict future values of that
variable.

   In example *note Example 5.7: regression, the service department of
the company wanted to be able to predict the time to repair equipment,
in order to improve the accuracy of their quotations.  It was suggested
that the time to repair might be related to the time between failures
and the duty cycle of the equipment.  The p-value of 0.1 was chosen for
this investigation.  In order to investigate this hypothesis, the
'REGRESSION' command was used.  This command not only tests if the
variables are related, but also identifies the potential linear
relationship.  *Note REGRESSION::.

     PSPP> get file='/usr/local/share/pspp/examples/repairs.sav'.
     PSPP> regression /variables = mtbf duty_cycle /dependent = mttr.
     PSPP> regression /variables = mtbf /dependent = mttr.
Output:
     1.3(1) REGRESSION.  Coefficients
     #=============================================#====#==========#====#=====#
     #                                             #  B |Std. Error|Beta|  t  #
     #========#====================================#====#==========#====#=====#
     #        |(Constant)                          #9.81|      1.50| .00| 6.54#
     #        |Mean time between failures (months) #3.10|       .10| .99|32.43#
     #        |Ratio of working to non-working time#1.09|      1.78| .02|  .61#
     #        |                                    #    |          |    |     #
     #========#====================================#====#==========#====#=====#

     1.3(2) REGRESSION.  Coefficients
     #=============================================#============#
     #                                             #Significance#
     #========#====================================#============#
     #        |(Constant)                          #         .10#
     #        |Mean time between failures (months) #         .00#
     #        |Ratio of working to non-working time#         .55#
     #        |                                    #            #
     #========#====================================#============#
     2.3(1) REGRESSION.  Coefficients
     #============================================#=====#==========#====#=====#
     #                                            #  B  |Std. Error|Beta|  t  #
     #========#===================================#=====#==========#====#=====#
     #        |(Constant)                         #10.50|       .96| .00|10.96#
     #        |Mean time between failures (months)# 3.11|       .09| .99|33.39#
     #        |                                   #     |          |    |     #
     #========#===================================#=====#==========#====#=====#

     2.3(2) REGRESSION.  Coefficients
     #============================================#============#
     #                                            #Significance#
     #========#===================================#============#
     #        |(Constant)                         #         .06#
     #        |Mean time between failures (months)#         .00#
     #        |                                   #            #
     #========#===================================#============#

Example 5.7: Linear regression analysis to find a predictor for MTTR.
The first attempt, including DUTY_CYCLE, produces some unacceptable high
significance values.  However the second attempt, which excludes
DUTY_CYCLE, produces significance values no higher than 0.06.  This
suggests that MTBF alone may be a suitable predictor for MTTR.

   The coefficients in the first table suggest that the formula MTTR =
9.81 + 3.1 \times MTBF + 1.09 \times DUTY_CYCLE can be used to predict
the time to repair.  However, the significance value for the DUTY_CYCLE
coefficient is very high, which would make this an unsafe predictor.
For this reason, the test was repeated, but omitting the DUTY_CYCLE
variable.  This time, the significance of all coefficients no higher
than 0.06, suggesting that at the 0.06 level, the formula MTTR = 10.5 +
3.11 \times MTBF is a reliable predictor of the time to repair.


File: pspp.info,  Node: Language,  Next: Expressions,  Prev: Using PSPP,  Up: Top

6 The PSPP language
*******************

This chapter discusses elements common to many PSPP commands.  Later
chapters will describe individual commands in detail.

* Menu:

* Tokens::                      Characters combine to form tokens.
* Commands::                    Tokens combine to form commands.
* Syntax Variants::             Batch vs. Interactive mode
* Types of Commands::           Commands come in several flavors.
* Order of Commands::           Commands combine to form syntax files.
* Missing Observations::        Handling missing observations.
* Datasets::                    Data organization.
* Files::                       Files used by PSPP.
* File Handles::                How files are named.
* BNF::                         How command syntax is described.


File: pspp.info,  Node: Tokens,  Next: Commands,  Up: Language

6.1 Tokens
==========

PSPP divides most syntax file lines into series of short chunks called
"tokens".  Tokens are then grouped to form commands, each of which tells
PSPP to take some action--read in data, write out data, perform a
statistical procedure, etc.  Each type of token is described below.

*Identifiers*
     Identifiers are names that typically specify variables, commands,
     or subcommands.  The first character in an identifier must be a
     letter, '#', or '@'.  The remaining characters in the identifier
     must be letters, digits, or one of the following special
     characters:

                               . _ $ # @

     Identifiers may be any length, but only the first 64 bytes are
     significant.  Identifiers are not case-sensitive: 'foobar',
     'Foobar', 'FooBar', 'FOOBAR', and 'FoObaR' are different
     representations of the same identifier.

     Some identifiers are reserved.  Reserved identifiers may not be
     used in any context besides those explicitly described in this
     manual.  The reserved identifiers are:

              ALL AND BY EQ GE GT LE LT NE NOT OR TO WITH

*Keywords*
     Keywords are a subclass of identifiers that form a fixed part of
     command syntax.  For example, command and subcommand names are
     keywords.  Keywords may be abbreviated to their first 3 characters
     if this abbreviation is unambiguous.  (Unique abbreviations of 3 or
     more characters are also accepted: 'FRE', 'FREQ', and 'FREQUENCIES'
     are equivalent when the last is a keyword.)

     Reserved identifiers are always used as keywords.  Other
     identifiers may be used both as keywords and as user-defined
     identifiers, such as variable names.

*Numbers*
     Numbers are expressed in decimal.  A decimal point is optional.
     Numbers may be expressed in scientific notation by adding 'e' and a
     base-10 exponent, so that '1.234e3' has the value 1234.  Here are
     some more examples of valid numbers:

          -5  3.14159265359  1e100  -.707  8945.

     Negative numbers are expressed with a '-' prefix.  However, in
     situations where a literal '-' token is expected, what appears to
     be a negative number is treated as '-' followed by a positive
     number.

     No white space is allowed within a number token, except for
     horizontal white space between '-' and the rest of the number.

     The last example above, '8945.' will be interpreted as two tokens,
     '8945' and '.', if it is the last token on a line.  *Note Forming
     commands of tokens: Commands.

*Strings*
     Strings are literal sequences of characters enclosed in pairs of
     single quotes (''') or double quotes ('"').  To include the
     character used for quoting in the string, double it, e.g. ''it''s
     an apostrophe''.  White space and case of letters are significant
     inside strings.

     Strings can be concatenated using '+', so that '"a" + 'b' + 'c'' is
     equivalent to ''abc''.  So that a long string may be broken across
     lines, a line break may precede or follow, or both precede and
     follow, the '+'.  (However, an entirely blank line preceding or
     following the '+' is interpreted as ending the current command.)

     Strings may also be expressed as hexadecimal character values by
     prefixing the initial quote character by 'x' or 'X'.  Regardless of
     the syntax file or active dataset's encoding, the hexadecimal
     digits in the string are interpreted as Unicode characters in UTF-8
     encoding.

     Individual Unicode code points may also be expressed by specifying
     the hexadecimal code point number in single or double quotes
     preceded by 'u' or 'U'.  For example, Unicode code point U+1D11E,
     the musical G clef character, could be expressed as 'U'1D11E''.
     Invalid Unicode code points (above U+10FFFF or in between U+D800
     and U+DFFF) are not allowed.

     When strings are concatenated with '+', each segment's prefix is
     considered individually.  For example, ''The G clef symbol is:' +
     u"1d11e" + "."' inserts a G clef symbol in the middle of an
     otherwise plain text string.

*Punctuators and Operators*
     These tokens are the punctuators and operators:

              , / = ( ) + - * / ** < <= <> > >= ~= & | .

     Most of these appear within the syntax of commands, but the period
     ('.') punctuator is used only at the end of a command.  It is a
     punctuator only as the last character on a line (except white
     space).  When it is the last non-space character on a line, a
     period is not treated as part of another token, even if it would
     otherwise be part of, e.g., an identifier or a floating-point
     number.


File: pspp.info,  Node: Commands,  Next: Syntax Variants,  Prev: Tokens,  Up: Language

6.2 Forming commands of tokens
==============================

Most PSPP commands share a common structure.  A command begins with a
command name, such as 'FREQUENCIES', 'DATA LIST', or 'N OF CASES'.  The
command name may be abbreviated to its first word, and each word in the
command name may be abbreviated to its first three or more characters,
where these abbreviations are unambiguous.

   The command name may be followed by one or more "subcommands".  Each
subcommand begins with a subcommand name, which may be abbreviated to
its first three letters.  Some subcommands accept a series of one or
more specifications, which follow the subcommand name, optionally
separated from it by an equals sign ('=').  Specifications may be
separated from each other by commas or spaces.  Each subcommand must be
separated from the next (if any) by a forward slash ('/').

   There are multiple ways to mark the end of a command.  The most
common way is to end the last line of the command with a period ('.') as
described in the previous section (*note Tokens::).  A blank line, or
one that consists only of white space or comments, also ends a command.


File: pspp.info,  Node: Syntax Variants,  Next: Types of Commands,  Prev: Commands,  Up: Language

6.3 Syntax Variants
===================

There are three variants of command syntax, which vary only in how they
detect the end of one command and the start of the next.

   In "interactive mode", which is the default for syntax typed at a
command prompt, a period as the last non-blank character on a line ends
a command.  A blank line also ends a command.

   In "batch mode", an end-of-line period or a blank line also ends a
command.  Additionally, it treats any line that has a non-blank
character in the leftmost column as beginning a new command.  Thus, in
batch mode the second and subsequent lines in a command must be
indented.

   Regardless of the syntax mode, a plus sign, minus sign, or period in
the leftmost column of a line is ignored and causes that line to begin a
new command.  This is most useful in batch mode, in which the first line
of a new command could not otherwise be indented, but it is accepted
regardless of syntax mode.

   The default mode for reading commands from a file is "auto mode".  It
is the same as batch mode, except that a line with a non-blank in the
leftmost column only starts a new command if that line begins with the
name of a PSPP command.  This correctly interprets most valid PSPP
syntax files regardless of the syntax mode for which they are intended.

   The '--interactive' (or '-i') or '--batch' (or '-b') options set the
syntax mode for files listed on the PSPP command line.  *Note Main
Options::, for more details.


File: pspp.info,  Node: Types of Commands,  Next: Order of Commands,  Prev: Syntax Variants,  Up: Language

6.4 Types of Commands
=====================

Commands in PSPP are divided roughly into six categories:

*Utility commands*
     Set or display various global options that affect PSPP operations.
     May appear anywhere in a syntax file.  *Note Utility commands:
     Utilities.

*File definition commands*
     Give instructions for reading data from text files or from special
     binary "system files".  Most of these commands replace any previous
     data or variables with new data or variables.  At least one file
     definition command must appear before the first command in any of
     the categories below.  *Note Data Input and Output::.

*Input program commands*
     Though rarely used, these provide tools for reading data files in
     arbitrary textual or binary formats.  *Note INPUT PROGRAM::.

*Transformations*
     Perform operations on data and write data to output files.
     Transformations are not carried out until a procedure is executed.

*Restricted transformations*
     Transformations that cannot appear in certain contexts.  *Note
     Order of Commands::, for details.

*Procedures*
     Analyze data, writing results of analyses to the listing file.
     Cause transformations specified earlier in the file to be
     performed.  In a more general sense, a "procedure" is any command
     that causes the active dataset (the data) to be read.


File: pspp.info,  Node: Order of Commands,  Next: Missing Observations,  Prev: Types of Commands,  Up: Language

6.5 Order of Commands
=====================

PSPP does not place many restrictions on ordering of commands.  The main
restriction is that variables must be defined before they are otherwise
referenced.  This section describes the details of command ordering, but
most users will have no need to refer to them.

   PSPP possesses five internal states, called "initial",
"input-program" "file-type", "transformation", and "procedure" states.
(Please note the distinction between the 'INPUT PROGRAM' and 'FILE TYPE'
_commands_ and the "input-program" and "file-type" _states_.)

   PSPP starts in the initial state.  Each successful completion of a
command may cause a state transition.  Each type of command has its own
rules for state transitions:

*Utility commands*
        * Valid in any state.
        * Do not cause state transitions.  Exception: when 'N OF CASES'
          is executed in the procedure state, it causes a transition to
          the transformation state.

*'DATA LIST'*
        * Valid in any state.
        * When executed in the initial or procedure state, causes a
          transition to the transformation state.
        * Clears the active dataset if executed in the procedure or
          transformation state.

*'INPUT PROGRAM'*
        * Invalid in input-program and file-type states.
        * Causes a transition to the intput-program state.
        * Clears the active dataset.

*'FILE TYPE'*
        * Invalid in intput-program and file-type states.
        * Causes a transition to the file-type state.
        * Clears the active dataset.

*Other file definition commands*
        * Invalid in input-program and file-type states.
        * Cause a transition to the transformation state.
        * Clear the active dataset, except for 'ADD FILES', 'MATCH
          FILES', and 'UPDATE'.

*Transformations*
        * Invalid in initial and file-type states.
        * Cause a transition to the transformation state.

*Restricted transformations*
        * Invalid in initial, input-program, and file-type states.
        * Cause a transition to the transformation state.

*Procedures*
        * Invalid in initial, input-program, and file-type states.
        * Cause a transition to the procedure state.


File: pspp.info,  Node: Missing Observations,  Next: Datasets,  Prev: Order of Commands,  Up: Language

6.6 Handling missing observations
=================================

PSPP includes special support for unknown numeric data values.  Missing
observations are assigned a special value, called the "system-missing
value".  This "value" actually indicates the absence of a value; it
means that the actual value is unknown.  Procedures automatically
exclude from analyses those observations or cases that have missing
values.  Details of missing value exclusion depend on the procedure and
can often be controlled by the user; refer to descriptions of individual
procedures for details.

   The system-missing value exists only for numeric variables.  String
variables always have a defined value, even if it is only a string of
spaces.

   Variables, whether numeric or string, can have designated
"user-missing values".  Every user-missing value is an actual value for
that variable.  However, most of the time user-missing values are
treated in the same way as the system-missing value.

   For more information on missing values, see the following sections:
*note Datasets::, *note MISSING VALUES::, *note Expressions::.  See also
the documentation on individual procedures for information on how they
handle missing values.


File: pspp.info,  Node: Datasets,  Next: Files,  Prev: Missing Observations,  Up: Language

6.7 Datasets
============

PSPP works with data organized into "datasets".  A dataset consists of a
set of "variables", which taken together are said to form a
"dictionary", and one or more "cases", each of which has one value for
each variable.

   At any given time PSPP has exactly one distinguished dataset, called
the "active dataset".  Most PSPP commands work only with the active
dataset.  In addition to the active dataset, PSPP also supports any
number of additional open datasets.  The 'DATASET' commands can choose a
new active dataset from among those that are open, as well as create and
destroy datasets (*note DATASET::).

   The sections below describe variables in more detail.

* Menu:

* Attributes::                  Attributes of variables.
* System Variables::            Variables automatically defined by PSPP.
* Sets of Variables::           Lists of variable names.
* Input and Output Formats::    Input and output formats.
* Scratch Variables::           Variables deleted by procedures.


File: pspp.info,  Node: Attributes,  Next: System Variables,  Up: Datasets

6.7.1 Attributes of Variables
-----------------------------

Each variable has a number of attributes, including:

*Name*
     An identifier, up to 64 bytes long.  Each variable must have a
     different name.  *Note Tokens::.

     Some system variable names begin with '$', but user-defined
     variables' names may not begin with '$'.

     The final character in a variable name should not be '.', because
     such an identifier will be misinterpreted when it is the final
     token on a line: 'FOO.' will be divided into two separate tokens,
     'FOO' and '.', indicating end-of-command.  *Note Tokens::.

     The final character in a variable name should not be '_', because
     some such identifiers are used for special purposes by PSPP
     procedures.

     As with all PSPP identifiers, variable names are not
     case-sensitive.  PSPP capitalizes variable names on output the same
     way they were capitalized at their point of definition in the
     input.

*Type*
     Numeric or string.

*Width*
     (string variables only) String variables with a width of 8
     characters or fewer are called "short string variables".  Short
     string variables may be used in a few contexts where "long string
     variables" (those with widths greater than 8) are not allowed.

*Position*
     Variables in the dictionary are arranged in a specific order.
     'DISPLAY' can be used to show this order: see *note DISPLAY::.

*Initialization*
     Either reinitialized to 0 or spaces for each case, or left at its
     existing value.  *Note LEAVE::.

*Missing values*
     Optionally, up to three values, or a range of values, or a specific
     value plus a range, can be specified as "user-missing values".
     There is also a "system-missing value" that is assigned to an
     observation when there is no other obvious value for that
     observation.  Observations with missing values are automatically
     excluded from analyses.  User-missing values are actual data
     values, while the system-missing value is not a value at all.
     *Note Missing Observations::.

*Variable label*
     A string that describes the variable.  *Note VARIABLE LABELS::.

*Value label*
     Optionally, these associate each possible value of the variable
     with a string.  *Note VALUE LABELS::.

*Print format*
     Display width, format, and (for numeric variables) number of
     decimal places.  This attribute does not affect how data are
     stored, just how they are displayed.  Example: a width of 8, with 2
     decimal places.  *Note Input and Output Formats::.

*Write format*
     Similar to print format, but used by the 'WRITE' command (*note
     WRITE::).

*Custom attributes*
     User-defined associations between names and values.  *Note VARIABLE
     ATTRIBUTE::.

*Role*
     The intended role of a variable for use in dialog boxes in
     graphical user interfaces.  *Note VARIABLE ROLE::.


File: pspp.info,  Node: System Variables,  Next: Sets of Variables,  Prev: Attributes,  Up: Datasets

6.7.2 Variables Automatically Defined by PSPP
---------------------------------------------

There are seven system variables.  These are not like ordinary variables
because system variables are not always stored.  They can be used only
in expressions.  These system variables, whose values and output formats
cannot be modified, are described below.

'$CASENUM'
     Case number of the case at the moment.  This changes as cases are
     shuffled around.

'$DATE'
     Date the PSPP process was started, in format A9, following the
     pattern 'DD MMM YY'.

'$JDATE'
     Number of days between 15 Oct 1582 and the time the PSPP process
     was started.

'$LENGTH'
     Page length, in lines, in format F11.

'$SYSMIS'
     System missing value, in format F1.

'$TIME'
     Number of seconds between midnight 14 Oct 1582 and the time the
     active dataset was read, in format F20.

'$WIDTH'
     Page width, in characters, in format F3.


File: pspp.info,  Node: Sets of Variables,  Next: Input and Output Formats,  Prev: System Variables,  Up: Datasets

6.7.3 Lists of variable names
-----------------------------

To refer to a set of variables, list their names one after another.
Optionally, their names may be separated by commas.  To include a range
of variables from the dictionary in the list, write the name of the
first and last variable in the range, separated by 'TO'.  For instance,
if the dictionary contains six variables with the names 'ID', 'X1',
'X2', 'GOAL', 'MET', and 'NEXTGOAL', in that order, then 'X2 TO MET'
would include variables 'X2', 'GOAL', and 'MET'.

   Commands that define variables, such as 'DATA LIST', give 'TO' an
alternate meaning.  With these commands, 'TO' define sequences of
variables whose names end in consecutive integers.  The syntax is two
identifiers that begin with the same root and end with numbers,
separated by 'TO'.  The syntax 'X1 TO X5' defines 5 variables, named
'X1', 'X2', 'X3', 'X4', and 'X5'.  The syntax 'ITEM0008 TO ITEM0013'
defines 6 variables, named 'ITEM0008', 'ITEM0009', 'ITEM0010',
'ITEM0011', 'ITEM0012', and 'ITEM00013'.  The syntaxes 'QUES001 TO
QUES9' and 'QUES6 TO QUES3' are invalid.

   After a set of variables has been defined with 'DATA LIST' or another
command with this method, the same set can be referenced on later
commands using the same syntax.


File: pspp.info,  Node: Input and Output Formats,  Next: Scratch Variables,  Prev: Sets of Variables,  Up: Datasets

6.7.4 Input and Output Formats
------------------------------

An "input format" describes how to interpret the contents of an input
field as a number or a string.  It might specify that the field contains
an ordinary decimal number, a time or date, a number in binary or
hexadecimal notation, or one of several other notations.  Input formats
are used by commands such as 'DATA LIST' that read data or syntax files
into the PSPP active dataset.

   Every input format corresponds to a default "output format" that
specifies the formatting used when the value is output later.  It is
always possible to explicitly specify an output format that resembles
the input format.  Usually, this is the default, but in cases where the
input format is unfriendly to human readability, such as binary or
hexadecimal formats, the default output format is an easier-to-read
decimal format.

   Every variable has two output formats, called its "print format" and
"write format".  Print formats are used in most output contexts; write
formats are used only by 'WRITE' (*note WRITE::).  Newly created
variables have identical print and write formats, and 'FORMATS', the
most commonly used command for changing formats (*note FORMATS::), sets
both of them to the same value as well.  Thus, most of the time, the
distinction between print and write formats is unimportant.

   Input and output formats are specified to PSPP with a "format
specification" of the form 'TYPEW' or 'TYPEW.D', where TYPE is one of
the format types described later, W is a field width measured in
columns, and D is an optional number of decimal places.  If D is
omitted, a value of 0 is assumed.  Some formats do not allow a nonzero D
to be specified.

   The following sections describe the input and output formats
supported by PSPP.

* Menu:

* Basic Numeric Formats::       
* Custom Currency Formats::     
* Legacy Numeric Formats::      
* Binary and Hexadecimal Numeric Formats::  
* Time and Date Formats::       
* Date Component Formats::      
* String Formats::              


File: pspp.info,  Node: Basic Numeric Formats,  Next: Custom Currency Formats,  Up: Input and Output Formats

6.7.4.1 Basic Numeric Formats
.............................

The basic numeric formats are used for input and output of real numbers
in standard or scientific notation.  The following table shows an
example of how each format displays positive and negative numbers with
the default decimal point setting:

Format       ' 3141.59'     '-3141.59'
-------------------------------------------
F8.2         ' 3141.59'     '-3141.59'
COMMA9.2     ' 3,141.59'    '-3,141.59'
DOT9.2       ' 3.141,59'    '-3.141,59'
DOLLAR10.2   ' $3,141.59'   '-$3,141.59'
PCT9.2       ' 3141.59%'    '-3141.59%'
E8.1         ' 3.1E+003'    '-3.1E+003'

   On output, numbers in F format are expressed in standard decimal
notation with the requested number of decimal places.  The other formats
output some variation on this style:

   * Numbers in COMMA format are additionally grouped every three digits
     by inserting a grouping character.  The grouping character is
     ordinarily a comma, but it can be changed to a period (*note SET
     DECIMAL::).

   * DOT format is like COMMA format, but it interchanges the role of
     the decimal point and grouping characters.  That is, the current
     grouping character is used as a decimal point and vice versa.

   * DOLLAR format is like COMMA format, but it prefixes the number with
     '$'.

   * PCT format is like F format, but adds '%' after the number.

   * The E format always produces output in scientific notation.

   On input, the basic numeric formats accept positive and numbers in
standard decimal notation or scientific notation.  Leading and trailing
spaces are allowed.  An empty or all-spaces field, or one that contains
only a single period, is treated as the system missing value.

   In scientific notation, the exponent may be introduced by a sign ('+'
or '-'), or by one of the letters 'e' or 'd' (in uppercase or
lowercase), or by a letter followed by a sign.  A single space may
follow the letter or the sign or both.

   On fixed-format 'DATA LIST' (*note DATA LIST FIXED::) and in a few
other contexts, decimals are implied when the field does not contain a
decimal point.  In F6.5 format, for example, the field '314159' is taken
as the value 3.14159 with implied decimals.  Decimals are never implied
if an explicit decimal point is present or if scientific notation is
used.

   E and F formats accept the basic syntax already described.  The other
formats allow some additional variations:

   * COMMA, DOLLAR, and DOT formats ignore grouping characters within
     the integer part of the input field.  The identity of the grouping
     character depends on the format.

   * DOLLAR format allows a dollar sign to precede the number.  In a
     negative number, the dollar sign may precede or follow the minus
     sign.

   * PCT format allows a percent sign to follow the number.

   All of the basic number formats have a maximum field width of 40 and
accept no more than 16 decimal places, on both input and output.  Some
additional restrictions apply:

   * As input formats, the basic numeric formats allow no more decimal
     places than the field width.  As output formats, the field width
     must be greater than the number of decimal places; that is, large
     enough to allow for a decimal point and the number of requested
     decimal places.  DOLLAR and PCT formats must allow an additional
     column for '$' or '%'.

   * The default output format for a given input format increases the
     field width enough to make room for optional input characters.  If
     an input format calls for decimal places, the width is increased by
     1 to make room for an implied decimal point.  COMMA, DOT, and
     DOLLAR formats also increase the output width to make room for
     grouping characters.  DOLLAR and PCT further increase the output
     field width by 1 to make room for '$' or '%'.  The increased output
     width is capped at 40, the maximum field width.

   * The E format is exceptional.  For output, E format has a minimum
     width of 7 plus the number of decimal places.  The default output
     format for an E input format is an E format with at least 3 decimal
     places and thus a minimum width of 10.

   More details of basic numeric output formatting are given below:

   * Output rounds to nearest, with ties rounded away from zero.  Thus,
     2.5 is output as '3' in F1.0 format, and -1.125 as '-1.13' in F5.1
     format.

   * The system-missing value is output as a period in a field of
     spaces, placed in the decimal point's position, or in the rightmost
     column if no decimal places are requested.  A period is used even
     if the decimal point character is a comma.

   * A number that does not fill its field is right-justified within the
     field.

   * A number is too large for its field causes decimal places to be
     dropped to make room.  If dropping decimals does not make enough
     room, scientific notation is used if the field is wide enough.  If
     a number does not fit in the field, even in scientific notation,
     the overflow is indicated by filling the field with asterisks
     ('*').

   * COMMA, DOT, and DOLLAR formats insert grouping characters only if
     space is available for all of them.  Grouping characters are never
     inserted when all decimal places must be dropped.  Thus, 1234.56 in
     COMMA5.2 format is output as ' 1235' without a comma, even though
     there is room for one, because all decimal places were dropped.

   * DOLLAR or PCT format drop the '$' or '%' only if the number would
     not fit at all without it.  Scientific notation with '$' or '%' is
     preferred to ordinary decimal notation without it.

   * Except in scientific notation, a decimal point is included only
     when it is followed by a digit.  If the integer part of the number
     being output is 0, and a decimal point is included, then the zero
     before the decimal point is dropped.

     In scientific notation, the number always includes a decimal point,
     even if it is not followed by a digit.

   * A negative number includes a minus sign only in the presence of a
     nonzero digit: -0.01 is output as '-.01' in F4.2 format but as
     '  .0' in F4.1 format.  Thus, a "negative zero" never includes a
     minus sign.

   * In negative numbers output in DOLLAR format, the dollar sign
     follows the negative sign.  Thus, -9.99 in DOLLAR6.2 format is
     output as '-$9.99'.

   * In scientific notation, the exponent is output as 'E' followed by
     '+' or '-' and exactly three digits.  Numbers with magnitude less
     than 10**-999 or larger than 10**999 are not supported by most
     computers, but if they are supported then their output is
     considered to overflow the field and will be output as asterisks.

   * On most computers, no more than 15 decimal digits are significant
     in output, even if more are printed.  In any case, output precision
     cannot be any higher than input precision; few data sets are
     accurate to 15 digits of precision.  Unavoidable loss of precision
     in intermediate calculations may also reduce precision of output.

   * Special values such as infinities and "not a number" values are
     usually converted to the system-missing value before printing.  In
     a few circumstances, these values are output directly.  In fields
     of width 3 or greater, special values are output as however many
     characters will fit from '+Infinity' or '-Infinity' for infinities,
     from 'NaN' for "not a number," or from 'Unknown' for other values
     (if any are supported by the system).  In fields under 3 columns
     wide, special values are output as asterisks.


File: pspp.info,  Node: Custom Currency Formats,  Next: Legacy Numeric Formats,  Prev: Basic Numeric Formats,  Up: Input and Output Formats

6.7.4.2 Custom Currency Formats
...............................

The custom currency formats are closely related to the basic numeric
formats, but they allow users to customize the output format.  The SET
command configures custom currency formats, using the syntax
     SET CCX="STRING".
where X is A, B, C, D, or E, and STRING is no more than 16 characters
long.

   STRING must contain exactly three commas or exactly three periods
(but not both), except that a single quote character may be used to
"escape" a following comma, period, or single quote.  If three commas
are used, commas will be used for grouping in output, and a period will
be used as the decimal point.  Uses of periods reverses these roles.

   The commas or periods divide STRING into four fields, called the
"negative prefix", "prefix", "suffix", and "negative suffix",
respectively.  The prefix and suffix are added to output whenever space
is available.  The negative prefix and negative suffix are always added
to a negative number when the output includes a nonzero digit.

   The following syntax shows how custom currency formats could be used
to reproduce basic numeric formats:

     SET CCA="-,,,".  /* Same as COMMA.
     SET CCB="-...".  /* Same as DOT.
     SET CCC="-,$,,". /* Same as DOLLAR.
     SET CCD="-,,%,". /* Like PCT, but groups with commas.

   Here are some more examples of custom currency formats.  The final
example shows how to use a single quote to escape a delimiter:

     SET CCA=",EUR,,-".   /* Euro.
     SET CCB="(,USD ,,)". /* US dollar.
     SET CCC="-.R$..".    /* Brazilian real.
     SET CCD="-,, NIS,".  /* Israel shekel.
     SET CCE="-.Rp'. ..". /* Indonesia Rupiah.

These formats would yield the following output:

Format    ' 3145.59'         '-3145.59'
------------------------------------------------
CCA12.2   ' EUR3,145.59'     'EUR3,145.59-'
CCB14.2   '  USD 3,145.59'   '(USD 3,145.59)'
CCC11.2   ' R$3.145,59'      '-R$3.145,59'
CCD13.2   ' 3,145.59 NIS'    '-3,145.59 NIS'
CCE10.0   ' Rp. 3.146'       '-Rp. 3.146'

   The default for all the custom currency formats is '-,,,', equivalent
to COMMA format.


File: pspp.info,  Node: Legacy Numeric Formats,  Next: Binary and Hexadecimal Numeric Formats,  Prev: Custom Currency Formats,  Up: Input and Output Formats

6.7.4.3 Legacy Numeric Formats
..............................

The N and Z numeric formats provide compatibility with legacy file
formats.  They have much in common:

   * Output is rounded to the nearest representable value, with ties
     rounded away from zero.

   * Numbers too large to display are output as a field filled with
     asterisks ('*').

   * The decimal point is always implicitly the specified number of
     digits from the right edge of the field, except that Z format input
     allows an explicit decimal point.

   * Scientific notation may not be used.

   * The system-missing value is output as a period in a field of
     spaces.  The period is placed just to the right of the implied
     decimal point in Z format, or at the right end in N format or in Z
     format if no decimal places are requested.  A period is used even
     if the decimal point character is a comma.

   * Field width may range from 1 to 40.  Decimal places may range from
     0 up to the field width, to a maximum of 16.

   * When a legacy numeric format used for input is converted to an
     output format, it is changed into the equivalent F format.  The
     field width is increased by 1 if any decimal places are specified,
     to make room for a decimal point.  For Z format, the field width is
     increased by 1 more column, to make room for a negative sign.  The
     output field width is capped at 40 columns.

N Format
........

The N format supports input and output of fields that contain only
digits.  On input, leading or trailing spaces, a decimal point, or any
other non-digit character causes the field to be read as the
system-missing value.  As a special exception, an N format used on 'DATA
LIST FREE' or 'DATA LIST LIST' is treated as the equivalent F format.

   On output, N pads the field on the left with zeros.  Negative numbers
are output like the system-missing value.

Z Format
........

The Z format is a "zoned decimal" format used on IBM mainframes.  Z
format encodes the sign as part of the final digit, which must be one of
the following:
     0123456789
     {ABCDEFGHI
     }JKLMNOPQR
where the characters in each row represent digits 0 through 9 in order.
Characters in the first two rows indicate a positive sign; those in the
third indicate a negative sign.

   On output, Z fields are padded on the left with spaces.  On input,
leading and trailing spaces are ignored.  Any character in an input
field other than spaces, the digit characters above, and '.' causes the
field to be read as system-missing.

   The decimal point character for input and output is always '.', even
if the decimal point character is a comma (*note SET DECIMAL::).

   Nonzero, negative values output in Z format are marked as negative
even when no nonzero digits are output.  For example, -0.2 is output in
Z1.0 format as 'J'.  The "negative zero" value supported by most
machines is output as positive.


File: pspp.info,  Node: Binary and Hexadecimal Numeric Formats,  Next: Time and Date Formats,  Prev: Legacy Numeric Formats,  Up: Input and Output Formats

6.7.4.4 Binary and Hexadecimal Numeric Formats
..............................................

The binary and hexadecimal formats are primarily designed for
compatibility with existing machine formats, not for human readability.
All of them therefore have a F format as default output format.  Some of
these formats are only portable between machines with compatible byte
ordering (endianness) or floating-point format.

   Binary formats use byte values that in text files are interpreted as
special control functions, such as carriage return and line feed.  Thus,
data in binary formats should not be included in syntax files or read
from data files with variable-length records, such as ordinary text
files.  They may be read from or written to data files with fixed-length
records.  *Note FILE HANDLE::, for information on working with
fixed-length records.

P and PK Formats
................

These are binary-coded decimal formats, in which every byte (except the
last, in P format) represents two decimal digits.  The most-significant
4 bits of the first byte is the most-significant decimal digit, the
least-significant 4 bits of the first byte is the next decimal digit,
and so on.

   In P format, the most-significant 4 bits of the last byte are the
least-significant decimal digit.  The least-significant 4 bits represent
the sign: decimal 15 indicates a negative value, decimal 13 indicates a
positive value.

   Numbers are rounded downward on output.  The system-missing value and
numbers outside representable range are output as zero.

   The maximum field width is 16.  Decimal places may range from 0 up to
the number of decimal digits represented by the field.

   The default output format is an F format with twice the input field
width, plus one column for a decimal point (if decimal places were
requested).

IB and PIB Formats
..................

These are integer binary formats.  IB reads and writes 2's complement
binary integers, and PIB reads and writes unsigned binary integers.  The
byte ordering is by default the host machine's, but SET RIB may be used
to select a specific byte ordering for reading (*note SET RIB::) and SET
WIB, similarly, for writing (*note SET WIB::).

   The maximum field width is 8.  Decimal places may range from 0 up to
the number of decimal digits in the largest value representable in the
field width.

   The default output format is an F format whose width is the number of
decimal digits in the largest value representable in the field width,
plus 1 if the format has decimal places.

RB Format
.........

This is a binary format for real numbers.  By default it reads and
writes the host machine's floating-point format, but SET RRB may be used
to select an alternate floating-point format for reading (*note SET
RRB::) and SET WRB, similarly, for writing (*note SET WRB::).

   The recommended field width depends on the floating-point format.
NATIVE (the default format), IDL, IDB, VD, VG, and ZL formats should use
a field width of 8.  ISL, ISB, VF, and ZS formats should use a field
width of 4.  Other field widths will not produce useful results.  The
maximum field width is 8.  No decimal places may be specified.

   The default output format is F8.2.

PIBHEX and RBHEX Formats
........................

These are hexadecimal formats, for reading and writing binary formats
where each byte has been recoded as a pair of hexadecimal digits.

   A hexadecimal field consists solely of hexadecimal digits '0'...'9'
and 'A'...'F'.  Uppercase and lowercase are accepted on input; output is
in uppercase.

   Other than the hexadecimal representation, these formats are
equivalent to PIB and RB formats, respectively.  However, bytes in
PIBHEX format are always ordered with the most-significant byte first
(big-endian order), regardless of the host machine's native byte order
or PSPP settings.

   Field widths must be even and between 2 and 16.  RBHEX format allows
no decimal places; PIBHEX allows as many decimal places as a PIB format
with half the given width.


File: pspp.info,  Node: Time and Date Formats,  Next: Date Component Formats,  Prev: Binary and Hexadecimal Numeric Formats,  Up: Input and Output Formats

6.7.4.5 Time and Date Formats
.............................

In PSPP, a "time" is an interval.  The time formats translate between
human-friendly descriptions of time intervals and PSPP's internal
representation of time intervals, which is simply the number of seconds
in the interval.  PSPP has two time formats:

Time Format   Template                    Example
----------------------------------------------------------------------
TIME          'hh:MM:SS.ss'               '04:31:17.01'
DTIME         'DD HH:MM:SS.ss'            '00 04:31:17.01'

   A "date" is a moment in the past or the future.  Internally, PSPP
represents a date as the number of seconds since the "epoch", midnight,
Oct.  14, 1582.  The date formats translate between human-readable dates
and PSPP's numeric representation of dates and times.  PSPP has several
date formats:

Date Format   Template                    Example
----------------------------------------------------------------------
DATE          'dd-mmm-yyyy'               '01-OCT-1978'
ADATE         'mm/dd/yyyy'                '10/01/1978'
EDATE         'dd.mm.yyyy'                '01.10.1978'
JDATE         'yyyyjjj'                   '1978274'
SDATE         'yyyy/mm/dd'                '1978/10/01'
QYR           'q Q yyyy'                  '3 Q 1978'
MOYR          'mmm yyyy'                  'OCT 1978'
WKYR          'ww WK yyyy'                '40 WK 1978'
DATETIME      'dd-mmm-yyyy HH:MM:SS.ss'   '01-OCT-1978 04:31:17.01'

   The templates in the preceding tables describe how the time and date
formats are input and output:

'dd'
     Day of month, from 1 to 31.  Always output as two digits.

'mm'
'mmm'
     Month.  In output, 'mm' is output as two digits, 'mmm' as the first
     three letters of an English month name (January, February, ...).
     In input, both of these formats, plus Roman numerals, are accepted.

'yyyy'
     Year.  In output, DATETIME always produces a 4-digit year; other
     formats can produce a 2- or 4-digit year.  The century assumed for
     2-digit years depends on the EPOCH setting (*note SET EPOCH::).  In
     output, a year outside the epoch causes the whole field to be
     filled with asterisks ('*').

'jjj'
     Day of year (Julian day), from 1 to 366.  This is exactly three
     digits giving the count of days from the start of the year.
     January 1 is considered day 1.

'q'
     Quarter of year, from 1 to 4.  Quarters start on January 1, April
     1, July 1, and October 1.

'ww'
     Week of year, from 1 to 53.  Output as exactly two digits.  January
     1 is the first day of week 1.

'DD'
     Count of days, which may be positive or negative.  Output as at
     least two digits.

'hh'
     Count of hours, which may be positive or negative.  Output as at
     least two digits.

'HH'
     Hour of day, from 0 to 23.  Output as exactly two digits.

'MM'
     Minute of hour, from 0 to 59.  Output as exactly two digits.

'SS.ss'
     Seconds within minute, from 0 to 59.  The integer part is output as
     exactly two digits.  On output, seconds and fractional seconds may
     or may not be included, depending on field width and decimal
     places.  On input, seconds and fractional seconds are optional.
     The DECIMAL setting controls the character accepted and displayed
     as the decimal point (*note SET DECIMAL::).

   For output, the date and time formats use the delimiters indicated in
the table.  For input, date components may be separated by spaces or by
one of the characters '-', '/', '.', or ',', and time components may be
separated by spaces, ':', or '.'.  On input, the 'Q' separating quarter
from year and the 'WK' separating week from year may be uppercase or
lowercase, and the spaces around them are optional.

   On input, all time and date formats accept any amount of leading and
trailing white space.

   The maximum width for time and date formats is 40 columns.  Minimum
input and output width for each of the time and date formats is shown
below:

Format     Min.  Input Width   Min.  Output Width   Option
-------------------------------------------------------------------
DATE       8                   9                    4-digit year
ADATE      8                   8                    4-digit year
EDATE      8                   8                    4-digit year
JDATE      5                   5                    4-digit year
SDATE      8                   8                    4-digit year
QYR        4                   6                    4-digit year
MOYR       6                   6                    4-digit year
WKYR       6                   8                    4-digit year
DATETIME   17                  17                   seconds
TIME       5                   5                    seconds
DTIME      8                   8                    seconds
In the table, "Option" describes what increased output width enables:

4-digit year
     A field 2 columns wider than minimum will include a 4-digit year.
     (DATETIME format always includes a 4-digit year.)

seconds
     A field 3 columns wider than minimum will include seconds as well
     as minutes.  A field 5 columns wider than minimum, or more, can
     also include a decimal point and fractional seconds (but no more
     than allowed by the format's decimal places).

   For the time and date formats, the default output format is the same
as the input format, except that PSPP increases the field width, if
necessary, to the minimum allowed for output.

   Time or dates narrower than the field width are right-justified
within the field.

   When a time or date exceeds the field width, characters are trimmed
from the end until it fits.  This can occur in an unusual situation,
e.g. with a year greater than 9999 (which adds an extra digit), or for a
negative value on TIME or DTIME (which adds a leading minus sign).

   The system-missing value is output as a period at the right end of
the field.


File: pspp.info,  Node: Date Component Formats,  Next: String Formats,  Prev: Time and Date Formats,  Up: Input and Output Formats

6.7.4.6 Date Component Formats
..............................

The WKDAY and MONTH formats provide input and output for the names of
weekdays and months, respectively.

   On output, these formats convert a number between 1 and 7, for WKDAY,
or between 1 and 12, for MONTH, into the English name of a day or month,
respectively.  If the name is longer than the field, it is trimmed to
fit.  If the name is shorter than the field, it is padded on the right
with spaces.  Values outside the valid range, and the system-missing
value, are output as all spaces.

   On input, English weekday or month names (in uppercase or lowercase)
are converted back to their corresponding numbers.  Weekday and month
names may be abbreviated to their first 2 or 3 letters, respectively.

   The field width may range from 2 to 40, for WKDAY, or from 3 to 40,
for MONTH. No decimal places are allowed.

   The default output format is the same as the input format.


File: pspp.info,  Node: String Formats,  Prev: Date Component Formats,  Up: Input and Output Formats

6.7.4.7 String Formats
......................

The A and AHEX formats are the only ones that may be assigned to string
variables.  Neither format allows any decimal places.

   In A format, the entire field is treated as a string value.  The
field width may range from 1 to 32,767, the maximum string width.  The
default output format is the same as the input format.

   In AHEX format, the field is composed of characters in a string
encoded as hex digit pairs.  On output, hex digits are output in
uppercase; on input, uppercase and lowercase are both accepted.  The
default output format is A format with half the input width.


File: pspp.info,  Node: Scratch Variables,  Prev: Input and Output Formats,  Up: Datasets

6.7.5 Scratch Variables
-----------------------

Most of the time, variables don't retain their values between cases.
Instead, either they're being read from a data file or the active
dataset, in which case they assume the value read, or, if created with
'COMPUTE' or another transformation, they're initialized to the
system-missing value or to blanks, depending on type.

   However, sometimes it's useful to have a variable that keeps its
value between cases.  You can do this with 'LEAVE' (*note LEAVE::), or
you can use a "scratch variable".  Scratch variables are variables whose
names begin with an octothorpe ('#').

   Scratch variables have the same properties as variables left with
'LEAVE': they retain their values between cases, and for the first case
they are initialized to 0 or blanks.  They have the additional property
that they are deleted before the execution of any procedure.  For this
reason, scratch variables can't be used for analysis.  To use a scratch
variable in an analysis, use 'COMPUTE' (*note COMPUTE::) to copy its
value into an ordinary variable, then use that ordinary variable in the
analysis.


File: pspp.info,  Node: Files,  Next: File Handles,  Prev: Datasets,  Up: Language

6.8 Files Used by PSPP
======================

PSPP makes use of many files each time it runs.  Some of these it reads,
some it writes, some it creates.  Here is a table listing the most
important of these files:

*command file*
*syntax file*
     These names (synonyms) refer to the file that contains instructions
     that tell PSPP what to do.  The syntax file's name is specified on
     the PSPP command line.  Syntax files can also be read with
     'INCLUDE' (*note INCLUDE::).

*data file*
     Data files contain raw data in text or binary format.  Data can
     also be embedded in a syntax file with 'BEGIN DATA' and 'END DATA'.

*listing file*
     One or more output files are created by PSPP each time it is run.
     The output files receive the tables and charts produced by
     statistical procedures.  The output files may be in any number of
     formats, depending on how PSPP is configured.

*system file*
     System files are binary files that store a dictionary and a set of
     cases.  'GET' and 'SAVE' read and write system files.

*portable file*
     Portable files are files in a text-based format that store a
     dictionary and a set of cases.  'IMPORT' and 'EXPORT' read and
     write portable files.


File: pspp.info,  Node: File Handles,  Next: BNF,  Prev: Files,  Up: Language

6.9 File Handles
================

A "file handle" is a reference to a data file, system file, or portable
file.  Most often, a file handle is specified as the name of a file as a
string, that is, enclosed within ''' or '"'.

   A file name string that begins or ends with '|' is treated as the
name of a command to pipe data to or from.  You can use this feature to
read data over the network using a program such as 'curl' (e.g. 'GET
'|curl -s -S http://example.com/mydata.sav''), to read compressed data
from a file using a program such as 'zcat' (e.g. 'GET '|zcat
mydata.sav.gz''), and for many other purposes.

   PSPP also supports declaring named file handles with the 'FILE
HANDLE' command.  This command associates an identifier of your choice
(the file handle's name) with a file.  Later, the file handle name can
be substituted for the name of the file.  When PSPP syntax accesses a
file multiple times, declaring a named file handle simplifies updating
the syntax later to use a different file.  Use of 'FILE HANDLE' is also
required to read data files in binary formats.  *Note FILE HANDLE::, for
more information.

   In some circumstances, PSPP must distinguish whether a file handle
refers to a system file or a portable file.  When this is necessary to
read a file, e.g. as an input file for 'GET' or 'MATCH FILES', PSPP uses
the file's contents to decide.  In the context of writing a file, e.g.
as an output file for 'SAVE' or 'AGGREGATE', PSPP decides based on the
file's name: if it ends in '.por' (with any capitalization), then PSPP
writes a portable file; otherwise, PSPP writes a system file.

   INLINE is reserved as a file handle name.  It refers to the "data
file" embedded into the syntax file between 'BEGIN DATA' and 'END DATA'.
*Note BEGIN DATA::, for more information.

   The file to which a file handle refers may be reassigned on a later
'FILE HANDLE' command if it is first closed using 'CLOSE FILE HANDLE'.
*Note CLOSE FILE HANDLE::, for more information.


File: pspp.info,  Node: BNF,  Prev: File Handles,  Up: Language

6.10 Backus-Naur Form
=====================

The syntax of some parts of the PSPP language is presented in this
manual using the formalism known as "Backus-Naur Form", or BNF. The
following table describes BNF:

   * Words in all-uppercase are PSPP keyword tokens.  In BNF, these are
     often called "terminals".  There are some special terminals, which
     are written in lowercase for clarity:

     'number'
          A real number.

     'integer'
          An integer number.

     'string'
          A string.

     'var-name'
          A single variable name.

     '=', '/', '+', '-', etc.
          Operators and punctuators.

     '.'
          The end of the command.  This is not necessarily an actual dot
          in the syntax file: *Note Commands::, for more details.

   * Other words in all lowercase refer to BNF definitions, called
     "productions".  These productions are also known as "nonterminals".
     Some nonterminals are very common, so they are defined here in
     English for clarity:

     'var-list'
          A list of one or more variable names or the keyword 'ALL'.

     'expression'
          An expression.  *Note Expressions::, for details.

   * '::=' means "is defined as".  The left side of '::=' gives the name
     of the nonterminal being defined.  The right side of '::=' gives
     the definition of that nonterminal.  If the right side is empty,
     then one possible expansion of that nonterminal is nothing.  A BNF
     definition is called a "production".

   * So, the key difference between a terminal and a nonterminal is that
     a terminal cannot be broken into smaller parts--in fact, every
     terminal is a single token (*note Tokens::).  On the other hand,
     nonterminals are composed of a (possibly empty) sequence of
     terminals and nonterminals.  Thus, terminals indicate the deepest
     level of syntax description.  (In parsing theory, terminals are the
     leaves of the parse tree; nonterminals form the branches.)

   * The first nonterminal defined in a set of productions is called the
     "start symbol".  The start symbol defines the entire syntax for
     that command.


File: pspp.info,  Node: Expressions,  Next: Data Input and Output,  Prev: Language,  Up: Top

7 Mathematical Expressions
**************************

Expressions share a common syntax each place they appear in PSPP
commands.  Expressions are made up of "operands", which can be numbers,
strings, or variable names, separated by "operators".  There are five
types of operators: grouping, arithmetic, logical, relational, and
functions.

   Every operator takes one or more operands as input and yields exactly
one result as output.  Depending on the operator, operands accept
strings or numbers as operands.  With few exceptions, operands may be
full-fledged expressions in themselves.

* Menu:

* Boolean Values::                 Boolean values
* Missing Values in Expressions::  Using missing values in expressions
* Grouping Operators::             parentheses
* Arithmetic Operators::           add sub mul div pow
* Logical Operators::              AND NOT OR
* Relational Operators::           EQ GE GT LE LT NE
* Functions::                      More-sophisticated operators
* Order of Operations::            Operator precedence


File: pspp.info,  Node: Boolean Values,  Next: Missing Values in Expressions,  Up: Expressions

7.1 Boolean Values
==================

Some PSPP operators and expressions work with Boolean values, which
represent true/false conditions.  Booleans have only three possible
values: 0 (false), 1 (true), and system-missing (unknown).
System-missing is neither true nor false and indicates that the true
value is unknown.

   Boolean-typed operands or function arguments must take on one of
these three values.  Other values are considered false, but provoke a
warning when the expression is evaluated.

   Strings and Booleans are not compatible, and neither may be used in
place of the other.


File: pspp.info,  Node: Missing Values in Expressions,  Next: Grouping Operators,  Prev: Boolean Values,  Up: Expressions

7.2 Missing Values in Expressions
=================================

Most numeric operators yield system-missing when given any
system-missing operand.  A string operator given any system-missing
operand typically results in the empty string.  Exceptions are listed
under particular operator descriptions.

   String user-missing values are not treated specially in expressions.

   User-missing values for numeric variables are always transformed into
the system-missing value, except inside the arguments to the 'VALUE' and
'SYSMIS' functions.

   The missing-value functions can be used to precisely control how
missing values are treated in expressions.  *Note Missing Value
Functions::, for more details.


File: pspp.info,  Node: Grouping Operators,  Next: Arithmetic Operators,  Prev: Missing Values in Expressions,  Up: Expressions

7.3 Grouping Operators
======================

Parentheses ('()') are the grouping operators.  Surround an expression
with parentheses to force early evaluation.

   Parentheses also surround the arguments to functions, but in that
situation they act as punctuators, not as operators.


File: pspp.info,  Node: Arithmetic Operators,  Next: Logical Operators,  Prev: Grouping Operators,  Up: Expressions

7.4 Arithmetic Operators
========================

The arithmetic operators take numeric operands and produce numeric
results.

'A + B'
     Yields the sum of A and B.

'A - B'
     Subtracts B from A and yields the difference.

'A * B'
     Yields the product of A and B.  If either A or B is 0, then the
     result is 0, even if the other operand is missing.

'A / B'
     Divides A by B and yields the quotient.  If A is 0, then the result
     is 0, even if B is missing.  If B is zero, the result is
     system-missing.

'A ** B'
     Yields the result of raising A to the power B.  If A is negative
     and B is not an integer, the result is system-missing.  The result
     of '0**0' is system-missing as well.

'- A'
     Reverses the sign of A.


File: pspp.info,  Node: Logical Operators,  Next: Relational Operators,  Prev: Arithmetic Operators,  Up: Expressions

7.5 Logical Operators
=====================

The logical operators take logical operands and produce logical results,
meaning "true or false."  Logical operators are not true Boolean
operators because they may also result in a system-missing value.  *Note
Boolean Values::, for more information.

'A AND B'
'A & B'
     True if both A and B are true, false otherwise.  If one operand is
     false, the result is false even if the other is missing.  If both
     operands are missing, the result is missing.

'A OR B'
'A | B'
     True if at least one of A and B is true.  If one operand is true,
     the result is true even if the other operand is missing.  If both
     operands are missing, the result is missing.

'NOT A'
'~ A'
     True if A is false.  If the operand is missing, then the result is
     missing.


File: pspp.info,  Node: Relational Operators,  Next: Functions,  Prev: Logical Operators,  Up: Expressions

7.6 Relational Operators
========================

The relational operators take numeric or string operands and produce
Boolean results.

   Strings cannot be compared to numbers.  When strings of different
lengths are compared, the shorter string is right-padded with spaces to
match the length of the longer string.

   The results of string comparisons, other than tests for equality or
inequality, depend on the character set in use.  String comparisons are
case-sensitive.

'A EQ B'
'A = B'
     True if A is equal to B.

'A LE B'
'A <= B'
     True if A is less than or equal to B.

'A LT B'
'A < B'
     True if A is less than B.

'A GE B'
'A >= B'
     True if A is greater than or equal to B.

'A GT B'
'A > B'
     True if A is greater than B.

'A NE B'
'A ~= B'
'A <> B'
     True if A is not equal to B.


File: pspp.info,  Node: Functions,  Next: Order of Operations,  Prev: Relational Operators,  Up: Expressions

7.7 Functions
=============

PSPP functions provide mathematical abilities above and beyond those
possible using simple operators.  Functions have a common syntax: each
is composed of a function name followed by a left parenthesis, one or
more arguments, and a right parenthesis.

   Function names are not reserved.  Their names are specially treated
only when followed by a left parenthesis, so that 'EXP(10)' refers to
the constant value e raised to the 10th power, but 'EXP' by itself
refers to the value of a variable called 'EXP'.

   The sections below describe each function in detail.

* Menu:

* Mathematics::                 EXP LG10 LN LNGAMMA SQRT
* Miscellaneous Mathematics::   ABS MOD MOD10 RND TRUNC
* Trigonometry::                ACOS ARCOS ARSIN ARTAN ASIN ATAN COS SIN TAN
* Missing Value Functions::     MISSING NMISS NVALID SYSMIS VALUE
* Set Membership::              ANY RANGE
* Statistical Functions::       CFVAR MAX MEAN MEDIAN MIN SD SUM VARIANCE
* String Functions::            CONCAT INDEX LENGTH LOWER LPAD LTRIM NUMBER
                                REPLACE RINDEX RPAD RTRIM STRING STRUNC SUBSTR
                                UPCASE
* Time and Date::               CTIME.xxx DATE.xxx TIME.xxx XDATE.xxx
                                DATEDIFF DATESUM
* Miscellaneous Functions::     LAG YRMODA VALUELABEL
* Statistical Distribution Functions::  PDF CDF SIG IDF RV NPDF NCDF


File: pspp.info,  Node: Mathematics,  Next: Miscellaneous Mathematics,  Up: Functions

7.7.1 Mathematical Functions
----------------------------

Advanced mathematical functions take numeric arguments and produce
numeric results.

 -- Function: EXP (EXPONENT)
     Returns e (approximately 2.71828) raised to power EXPONENT.

 -- Function: LG10 (NUMBER)
     Takes the base-10 logarithm of NUMBER.  If NUMBER is not positive,
     the result is system-missing.

 -- Function: LN (NUMBER)
     Takes the base-e logarithm of NUMBER.  If NUMBER is not positive,
     the result is system-missing.

 -- Function: LNGAMMA (NUMBER)
     Yields the base-e logarithm of the complete gamma of NUMBER.  If
     NUMBER is a negative integer, the result is system-missing.

 -- Function: SQRT (NUMBER)
     Takes the square root of NUMBER.  If NUMBER is negative, the result
     is system-missing.


File: pspp.info,  Node: Miscellaneous Mathematics,  Next: Trigonometry,  Prev: Mathematics,  Up: Functions

7.7.2 Miscellaneous Mathematical Functions
------------------------------------------

Miscellaneous mathematical functions take numeric arguments and produce
numeric results.

 -- Function: ABS (NUMBER)
     Results in the absolute value of NUMBER.

 -- Function: MOD (NUMERATOR, DENOMINATOR)
     Returns the remainder (modulus) of NUMERATOR divided by
     DENOMINATOR.  If NUMERATOR is 0, then the result is 0, even if
     DENOMINATOR is missing.  If DENOMINATOR is 0, the result is
     system-missing.

 -- Function: MOD10 (NUMBER)
     Returns the remainder when NUMBER is divided by 10.  If NUMBER is
     negative, MOD10(NUMBER) is negative or zero.

 -- Function: RND (NUMBER [, MULT[, FUZZBITS]])
     Rounds NUMBER and rounds it to a multiple of MULT (by default 1).
     Halves are rounded away from zero, as are values that fall short of
     halves by less than FUZZBITS of errors in the least-significant
     bits of NUMBER.  If FUZZBITS is not specified then the default is
     taken from SET FUZZBITS (*note SET FUZZBITS::), which is 6 unless
     overridden.

 -- Function: TRUNC (NUMBER [, MULT[, FUZZBITS]])
     Rounds NUMBER to a multiple of MULT, toward zero.  For the default
     MULT of 1, this is equivalent to discarding the fractional part of
     NUMBER.  Values that fall short of a multiple of MULT by less than
     FUZZBITS of errors in the least-significant bits of NUMBER are
     rounded away from zero.  If FUZZBITS is not specified then the
     default is taken from SET FUZZBITS (*note SET FUZZBITS::), which is
     6 unless overridden.


File: pspp.info,  Node: Trigonometry,  Next: Missing Value Functions,  Prev: Miscellaneous Mathematics,  Up: Functions

7.7.3 Trigonometric Functions
-----------------------------

Trigonometric functions take numeric arguments and produce numeric
results.

 -- Function: ARCOS (NUMBER)
 -- Function: ACOS (NUMBER)
     Takes the arccosine, in radians, of NUMBER.  Results in
     system-missing if NUMBER is not between -1 and 1 inclusive.  This
     function is a PSPP extension.

 -- Function: ARSIN (NUMBER)
 -- Function: ASIN (NUMBER)
     Takes the arcsine, in radians, of NUMBER.  Results in
     system-missing if NUMBER is not between -1 and 1 inclusive.

 -- Function: ARTAN (NUMBER)
 -- Function: ATAN (NUMBER)
     Takes the arctangent, in radians, of NUMBER.

 -- Function: COS (ANGLE)
     Takes the cosine of ANGLE which should be in radians.

 -- Function: SIN (ANGLE)
     Takes the sine of ANGLE which should be in radians.

 -- Function: TAN (ANGLE)
     Takes the tangent of ANGLE which should be in radians.  Results in
     system-missing at values of ANGLE that are too close to odd
     multiples of \pi/2.  Portability: none.


File: pspp.info,  Node: Missing Value Functions,  Next: Set Membership,  Prev: Trigonometry,  Up: Functions

7.7.4 Missing-Value Functions
-----------------------------

Missing-value functions take various numeric arguments and yield various
types of results.  Except where otherwise stated below, the normal rules
of evaluation apply within expression arguments to these functions.  In
particular, user-missing values for numeric variables are converted to
system-missing values.

 -- Function: MISSING (EXPR)
     Returns 1 if EXPR has the system-missing value, 0 otherwise.

 -- Function: NMISS (EXPR [, EXPR]...)
     Each argument must be a numeric expression.  Returns the number of
     system-missing values in the list, which may include variable
     ranges using the 'VAR1 TO VAR2' syntax.

 -- Function: NVALID (EXPR [, EXPR]...)
     Each argument must be a numeric expression.  Returns the number of
     values in the list that are not system-missing.  The list may
     include variable ranges using the 'VAR1 TO VAR2' syntax.

 -- Function: SYSMIS (EXPR)
     When EXPR is simply the name of a numeric variable, returns 1 if
     the variable has the system-missing value, 0 if it is user-missing
     or not missing.  If given EXPR takes another form, results in 1 if
     the value is system-missing, 0 otherwise.

 -- Function: VALUE (VARIABLE)
     Prevents the user-missing values of VARIABLE from being transformed
     into system-missing values, and always results in the actual value
     of VARIABLE, whether it is valid, user-missing, or system-missing.


File: pspp.info,  Node: Set Membership,  Next: Statistical Functions,  Prev: Missing Value Functions,  Up: Functions

7.7.5 Set-Membership Functions
------------------------------

Set membership functions determine whether a value is a member of a set.
They take a set of numeric arguments or a set of string arguments, and
produce Boolean results.

   String comparisons are performed according to the rules given in
*note Relational Operators::.

 -- Function: ANY (VALUE, SET [, SET]...)
     Results in true if VALUE is equal to any of the SET values.
     Otherwise, results in false.  If VALUE is system-missing, returns
     system-missing.  System-missing values in SET do not cause '/NAME/'
     to return system-missing.

 -- Function: RANGE (VALUE, LOW, HIGH [, LOW, HIGH]...)
     Results in true if VALUE is in any of the intervals bounded by LOW
     and HIGH inclusive.  Otherwise, results in false.  Each LOW must be
     less than or equal to its corresponding HIGH value.  LOW and HIGH
     must be given in pairs.  If VALUE is system-missing, returns
     system-missing.  System-missing values in SET do not cause '/NAME/'
     to return system-missing.


File: pspp.info,  Node: Statistical Functions,  Next: String Functions,  Prev: Set Membership,  Up: Functions

7.7.6 Statistical Functions
---------------------------

Statistical functions compute descriptive statistics on a list of
values.  Some statistics can be computed on numeric or string values;
other can only be computed on numeric values.  Their results have the
same type as their arguments.  The current case's weighting factor
(*note WEIGHT::) has no effect on statistical functions.

   These functions' argument lists may include entire ranges of
variables using the 'VAR1 TO VAR2' syntax.

   Unlike most functions, statistical functions can return non-missing
values even when some of their arguments are missing.  Most statistical
functions, by default, require only 1 non-missing value to have a
non-missing return, but '/NAME/', '/NAME/', and '/NAME/' require 2.
These defaults can be increased (but not decreased) by appending a dot
and the minimum number of valid arguments to the function name.  For
example, 'MEAN.3(X, Y, Z)' would only return non-missing if all of 'X',
'Y', and 'Z' were valid.

 -- Function: CFVAR (NUMBER, NUMBER[, ...])
     Results in the coefficient of variation of the values of NUMBER.
     (The coefficient of variation is the standard deviation divided by
     the mean.)

 -- Function: MAX (VALUE, VALUE[, ...])
     Results in the value of the greatest VALUE.  The VALUEs may be
     numeric or string.

 -- Function: MEAN (NUMBER, NUMBER[, ...])
     Results in the mean of the values of NUMBER.

 -- Function: MEDIAN (NUMBER, NUMBER[, ...])
     Results in the median of the values of NUMBER.  Given an even
     number of nonmissing arguments, yields the mean of the two middle
     values.

 -- Function: MIN (NUMBER, NUMBER[, ...])
     Results in the value of the least VALUE.  The VALUEs may be numeric
     or string.

 -- Function: SD (NUMBER, NUMBER[, ...])
     Results in the standard deviation of the values of NUMBER.

 -- Function: SUM (NUMBER, NUMBER[, ...])
     Results in the sum of the values of NUMBER.

 -- Function: VARIANCE (NUMBER, NUMBER[, ...])
     Results in the variance of the values of NUMBER.


File: pspp.info,  Node: String Functions,  Next: Time and Date,  Prev: Statistical Functions,  Up: Functions

7.7.7 String Functions
----------------------

String functions take various arguments and return various results.

 -- Function: CONCAT (STRING, STRING[, ...])
     Returns a string consisting of each STRING in sequence.
     'CONCAT("abc", "def", "ghi")' has a value of '"abcdefghi"'.  The
     resultant string is truncated to a maximum of 255 characters.

 -- Function: INDEX (HAYSTACK, NEEDLE)
     Returns a positive integer indicating the position of the first
     occurrence of NEEDLE in HAYSTACK.  Returns 0 if HAYSTACK does not
     contain NEEDLE.  Returns system-missing if NEEDLE is an empty
     string.

 -- Function: INDEX (HAYSTACK, NEEDLES, NEEDLE_LEN)
     Divides NEEDLES into one or more needles, each with length
     NEEDLE_LEN.  Searches HAYSTACK for the first occurrence of each
     needle, and returns the smallest value.  Returns 0 if HAYSTACK does
     not contain any part in NEEDLE.  It is an error if NEEDLE_LEN does
     not evenly divide the length of NEEDLES.  Returns system-missing if
     NEEDLES is an empty string.

 -- Function: LENGTH (STRING)
     Returns the number of characters in STRING.

 -- Function: LOWER (STRING)
     Returns a string identical to STRING except that all uppercase
     letters are changed to lowercase letters.  The definitions of
     "uppercase" and "lowercase" are system-dependent.

 -- Function: LPAD (STRING, LENGTH)
     If STRING is at least LENGTH characters in length, returns STRING
     unchanged.  Otherwise, returns STRING padded with spaces on the
     left side to length LENGTH.  Returns an empty string if LENGTH is
     system-missing, negative, or greater than 255.

 -- Function: LPAD (STRING, LENGTH, PADDING)
     If STRING is at least LENGTH characters in length, returns STRING
     unchanged.  Otherwise, returns STRING padded with PADDING on the
     left side to length LENGTH.  Returns an empty string if LENGTH is
     system-missing, negative, or greater than 255, or if PADDING does
     not contain exactly one character.

 -- Function: LTRIM (STRING)
     Returns STRING, after removing leading spaces.  Other white space,
     such as tabs, carriage returns, line feeds, and vertical tabs, is
     not removed.

 -- Function: LTRIM (STRING, PADDING)
     Returns STRING, after removing leading PADDING characters.  If
     PADDING does not contain exactly one character, returns an empty
     string.

 -- Function: NUMBER (STRING, FORMAT)
     Returns the number produced when STRING is interpreted according to
     format specifier FORMAT.  If the format width W is less than the
     length of STRING, then only the first W characters in STRING are
     used, e.g. 'NUMBER("123", F3.0)' and 'NUMBER("1234", F3.0)' both
     have value 123.  If W is greater than STRING's length, then it is
     treated as if it were right-padded with spaces.  If STRING is not
     in the correct format for FORMAT, system-missing is returned.

 -- Function: REPLACE (HAYSTACK, NEEDLE, REPLACEMENT[, N])
     Returns string HAYSTACK with instances of NEEDLE replaced by
     REPLACEMENT.  If nonnegative integer N is specified, it limits the
     maximum number of replacements; otherwise, all instances of NEEDLE
     are replaced.

 -- Function: RINDEX (HAYSTACK, NEEDLE)
     Returns a positive integer indicating the position of the last
     occurrence of NEEDLE in HAYSTACK.  Returns 0 if HAYSTACK does not
     contain NEEDLE.  Returns system-missing if NEEDLE is an empty
     string.

 -- Function: RINDEX (HAYSTACK, NEEDLE, NEEDLE_LEN)
     Divides NEEDLE into parts, each with length NEEDLE_LEN.  Searches
     HAYSTACK for the last occurrence of each part, and returns the
     largest value.  Returns 0 if HAYSTACK does not contain any part in
     NEEDLE.  It is an error if NEEDLE_LEN does not evenly divide the
     length of NEEDLE.  Returns system-missing if NEEDLE is an empty
     string or if needle_len is less than 1.

 -- Function: RPAD (STRING, LENGTH)
     If STRING is at least LENGTH characters in length, returns STRING
     unchanged.  Otherwise, returns STRING padded with spaces on the
     right to length LENGTH.  Returns an empty string if LENGTH is
     system-missing, negative, or greater than 255.

 -- Function: RPAD (STRING, LENGTH, PADDING)
     If STRING is at least LENGTH characters in length, returns STRING
     unchanged.  Otherwise, returns STRING padded with PADDING on the
     right to length LENGTH.  Returns an empty string if LENGTH is
     system-missing, negative, or greater than 255, or if PADDING does
     not contain exactly one character.

 -- Function: RTRIM (STRING)
     Returns STRING, after removing trailing spaces.  Other types of
     white space are not removed.

 -- Function: RTRIM (STRING, PADDING)
     Returns STRING, after removing trailing PADDING characters.  If
     PADDING does not contain exactly one character, returns an empty
     string.

 -- Function: STRING (NUMBER, FORMAT)
     Returns a string corresponding to NUMBER in the format given by
     format specifier FORMAT.  For example, 'STRING(123.56, F5.1)' has
     the value '"123.6"'.

 -- Function: STRUNC (STRING, N)
     Returns STRING, first trimming it to at most N bytes, then removing
     trailing spaces.  Returns an empty string if N is missing or
     negative.

 -- Function: SUBSTR (STRING, START)
     Returns a string consisting of the value of STRING from position
     START onward.  Returns an empty string if START is system-missing,
     less than 1, or greater than the length of STRING.

 -- Function: SUBSTR (STRING, START, COUNT)
     Returns a string consisting of the first COUNT characters from
     STRING beginning at position START.  Returns an empty string if
     START or COUNT is system-missing, if START is less than 1 or
     greater than the number of characters in STRING, or if COUNT is
     less than 1.  Returns a string shorter than COUNT characters if
     START + COUNT - 1 is greater than the number of characters in
     STRING.  Examples: 'SUBSTR("abcdefg", 3, 2)' has value '"cd"';
     'SUBSTR("nonsense", 4, 10)' has the value '"sense"'.

 -- Function: UPCASE (STRING)
     Returns STRING, changing lowercase letters to uppercase letters.


File: pspp.info,  Node: Time and Date,  Next: Miscellaneous Functions,  Prev: String Functions,  Up: Functions

7.7.8 Time & Date Functions
---------------------------

For compatibility, PSPP considers dates before 15 Oct 1582 invalid.
Most time and date functions will not accept earlier dates.

* Menu:

* Time and Date Concepts::      How times & dates are defined and represented
* Time Construction::           TIME.{DAYS HMS}
* Time Extraction::             CTIME.{DAYS HOURS MINUTES SECONDS}
* Date Construction::           DATE.{DMY MDY MOYR QYR WKYR YRDAY}
* Date Extraction::             XDATE.{DATE HOUR JDAY MDAY MINUTE MONTH
                                       QUARTER SECOND TDAY TIME WEEK
                                       WKDAY YEAR}
* Time and Date Arithmetic::    DATEDIFF DATESUM


File: pspp.info,  Node: Time and Date Concepts,  Next: Time Construction,  Up: Time and Date

7.7.8.1 How times & dates are defined and represented
.....................................................

Times and dates are handled by PSPP as single numbers.  A "time" is an
interval.  PSPP measures times in seconds.  Thus, the following
intervals correspond with the numeric values given:

               10 minutes                        600
               1 hour                          3,600
               1 day, 3 hours, 10 seconds     97,210
               40 days                     3,456,000

   A "date", on the other hand, is a particular instant in the past or
the future.  PSPP represents a date as a number of seconds since
midnight preceding 14 Oct 1582.  Because midnight preceding the dates
given below correspond with the numeric PSPP dates given:

                   15 Oct 1582                86,400
                    4 Jul 1776         6,113,318,400
                    1 Jan 1900        10,010,390,400
                    1 Oct 1978        12,495,427,200
                   24 Aug 1995        13,028,601,600


File: pspp.info,  Node: Time Construction,  Next: Time Extraction,  Prev: Time and Date Concepts,  Up: Time and Date

7.7.8.2 Functions that Produce Times
....................................

These functions take numeric arguments and return numeric values that
represent times.

 -- Function: TIME.DAYS (NDAYS)
     Returns a time corresponding to NDAYS days.

 -- Function: TIME.HMS (NHOURS, NMINS, NSECS)
     Returns a time corresponding to NHOURS hours, NMINS minutes, and
     NSECS seconds.  The arguments may not have mixed signs: if any of
     them are positive, then none may be negative, and vice versa.


File: pspp.info,  Node: Time Extraction,  Next: Date Construction,  Prev: Time Construction,  Up: Time and Date

7.7.8.3 Functions that Examine Times
....................................

These functions take numeric arguments in PSPP time format and give
numeric results.

 -- Function: CTIME.DAYS (TIME)
     Results in the number of days and fractional days in TIME.

 -- Function: CTIME.HOURS (TIME)
     Results in the number of hours and fractional hours in TIME.

 -- Function: CTIME.MINUTES (TIME)
     Results in the number of minutes and fractional minutes in TIME.

 -- Function: CTIME.SECONDS (TIME)
     Results in the number of seconds and fractional seconds in TIME.
     ('CTIME.SECONDS' does nothing; 'CTIME.SECONDS(X)' is equivalent to
     'X'.)


File: pspp.info,  Node: Date Construction,  Next: Date Extraction,  Prev: Time Extraction,  Up: Time and Date

7.7.8.4 Functions that Produce Dates
....................................

These functions take numeric arguments and give numeric results that
represent dates.  Arguments taken by these functions are:

DAY
     Refers to a day of the month between 1 and 31.  Day 0 is also
     accepted and refers to the final day of the previous month.  Days
     29, 30, and 31 are accepted even in months that have fewer days and
     refer to a day near the beginning of the following month.

MONTH
     Refers to a month of the year between 1 and 12.  Months 0 and 13
     are also accepted and refer to the last month of the preceding year
     and the first month of the following year, respectively.

QUARTER
     Refers to a quarter of the year between 1 and 4.  The quarters of
     the year begin on the first day of months 1, 4, 7, and 10.

WEEK
     Refers to a week of the year between 1 and 53.

YDAY
     Refers to a day of the year between 1 and 366.

YEAR
     Refers to a year, 1582 or greater.  Years between 0 and 99 are
     treated according to the epoch set on SET EPOCH, by default
     beginning 69 years before the current date (*note SET EPOCH::).

   If these functions' arguments are out-of-range, they are correctly
normalized before conversion to date format.  Non-integers are rounded
toward zero.

 -- Function: DATE.DMY (DAY, MONTH, YEAR)
 -- Function: DATE.MDY (MONTH, DAY, YEAR)
     Results in a date value corresponding to the midnight before day
     DAY of month MONTH of year YEAR.

 -- Function: DATE.MOYR (MONTH, YEAR)
     Results in a date value corresponding to the midnight before the
     first day of month MONTH of year YEAR.

 -- Function: DATE.QYR (QUARTER, YEAR)
     Results in a date value corresponding to the midnight before the
     first day of quarter QUARTER of year YEAR.

 -- Function: DATE.WKYR (WEEK, YEAR)
     Results in a date value corresponding to the midnight before the
     first day of week WEEK of year YEAR.

 -- Function: DATE.YRDAY (YEAR, YDAY)
     Results in a date value corresponding to the day YDAY of year YEAR.


File: pspp.info,  Node: Date Extraction,  Next: Time and Date Arithmetic,  Prev: Date Construction,  Up: Time and Date

7.7.8.5 Functions that Examine Dates
....................................

These functions take numeric arguments in PSPP date or time format and
give numeric results.  These names are used for arguments:

DATE
     A numeric value in PSPP date format.

TIME
     A numeric value in PSPP time format.

TIME-OR-DATE
     A numeric value in PSPP time or date format.

 -- Function: XDATE.DATE (TIME-OR-DATE)
     For a time, results in the time corresponding to the number of
     whole days DATE-OR-TIME includes.  For a date, results in the date
     corresponding to the latest midnight at or before DATE-OR-TIME;
     that is, gives the date that DATE-OR-TIME is in.

 -- Function: XDATE.HOUR (TIME-OR-DATE)
     For a time, results in the number of whole hours beyond the number
     of whole days represented by DATE-OR-TIME.  For a date, results in
     the hour (as an integer between 0 and 23) corresponding to
     DATE-OR-TIME.

 -- Function: XDATE.JDAY (DATE)
     Results in the day of the year (as an integer between 1 and 366)
     corresponding to DATE.

 -- Function: XDATE.MDAY (DATE)
     Results in the day of the month (as an integer between 1 and 31)
     corresponding to DATE.

 -- Function: XDATE.MINUTE (TIME-OR-DATE)
     Results in the number of minutes (as an integer between 0 and 59)
     after the last hour in TIME-OR-DATE.

 -- Function: XDATE.MONTH (DATE)
     Results in the month of the year (as an integer between 1 and 12)
     corresponding to DATE.

 -- Function: XDATE.QUARTER (DATE)
     Results in the quarter of the year (as an integer between 1 and 4)
     corresponding to DATE.

 -- Function: XDATE.SECOND (TIME-OR-DATE)
     Results in the number of whole seconds after the last whole minute
     (as an integer between 0 and 59) in TIME-OR-DATE.

 -- Function: XDATE.TDAY (DATE)
     Results in the number of whole days from 14 Oct 1582 to DATE.

 -- Function: XDATE.TIME (DATE)
     Results in the time of day at the instant corresponding to DATE, as
     a time value.  This is the number of seconds since midnight on the
     day corresponding to DATE.

 -- Function: XDATE.WEEK (DATE)
     Results in the week of the year (as an integer between 1 and 53)
     corresponding to DATE.

 -- Function: XDATE.WKDAY (DATE)
     Results in the day of week (as an integer between 1 and 7)
     corresponding to DATE, where 1 represents Sunday.

 -- Function: XDATE.YEAR (DATE)
     Returns the year (as an integer 1582 or greater) corresponding to
     DATE.


File: pspp.info,  Node: Time and Date Arithmetic,  Prev: Date Extraction,  Up: Time and Date

7.7.8.6 Time and Date Arithmetic
................................

Ordinary arithmetic operations on dates and times often produce sensible
results.  Adding a time to, or subtracting one from, a date produces a
new date that much earlier or later.  The difference of two dates yields
the time between those dates.  Adding two times produces the combined
time.  Multiplying a time by a scalar produces a time that many times
longer.  Since times and dates are just numbers, the ordinary addition
and subtraction operators are employed for these purposes.

   Adding two dates does not produce a useful result.

   Dates and times may have very large values.  Thus, it is not a good
idea to take powers of these values; also, the accuracy of some
procedures may be affected.  If necessary, convert times or dates in
seconds to some other unit, like days or years, before performing
analysis.

   PSPP supplies a few functions for date arithmetic:

 -- Function: DATEDIFF (DATE2, DATE1, UNIT)
     Returns the span of time from DATE1 to DATE2 in terms of UNIT,
     which must be a quoted string, one of 'years', 'quarters',
     'months', 'weeks', 'days', 'hours', 'minutes', and 'seconds'.  The
     result is an integer, truncated toward zero.

     One year is considered to span from a given date to the same month,
     day, and time of day the next year.  Thus, from Jan. 1 of one year
     to Jan. 1 the next year is considered to be a full year, but
     Feb. 29 of a leap year to the following Feb. 28 is not.  Similarly,
     one month spans from a given day of the month to the same day of
     the following month.  Thus, there is never a full month from
     Jan. 31 of a given year to any day in the following February.

 -- Function: DATESUM (DATE, QUANTITY, UNIT[, METHOD])
     Returns DATE advanced by the given QUANTITY of the specified UNIT,
     which must be one of the strings 'years', 'quarters', 'months',
     'weeks', 'days', 'hours', 'minutes', and 'seconds'.

     When UNIT is 'years', 'quarters', or 'months', only the integer
     part of QUANTITY is considered.  Adding one of these units can
     cause the day of the month to exceed the number of days in the
     month.  In this case, the METHOD comes into play: if it is omitted
     or specified as 'closest' (as a quoted string), then the resulting
     day is the last day of the month; otherwise, if it is specified as
     'rollover', then the extra days roll over into the following month.

     When UNIT is 'weeks', 'days', 'hours', 'minutes', or 'seconds', the
     QUANTITY is not rounded to an integer and METHOD, if specified, is
     ignored.


File: pspp.info,  Node: Miscellaneous Functions,  Next: Statistical Distribution Functions,  Prev: Time and Date,  Up: Functions

7.7.9 Miscellaneous Functions
-----------------------------

 -- Function: LAG (VARIABLE[, N])

     VARIABLE must be a numeric or string variable name.  'LAG' yields
     the value of that variable for the case N before the current one.
     Results in system-missing (for numeric variables) or blanks (for
     string variables) for the first N cases.

     'LAG' obtains values from the cases that become the new active
     dataset after a procedure executes.  Thus, 'LAG' will not return
     values from cases dropped by transformations such as 'SELECT IF',
     and transformations like 'COMPUTE' that modify data will change the
     values returned by 'LAG'.  These are both the case whether these
     transformations precede or follow the use of 'LAG'.

     If 'LAG' is used before 'TEMPORARY', then the values it returns are
     those in cases just before 'TEMPORARY'.  'LAG' may not be used
     after 'TEMPORARY'.

     If omitted, NCASES defaults to 1.  Otherwise, NCASES must be a
     small positive constant integer.  There is no explicit limit, but
     use of a large value will increase memory consumption.

 -- Function: YRMODA (YEAR, MONTH, DAY)
     YEAR is a year, either between 0 and 99 or at least 1582.  Unlike
     other PSPP date functions, years between 0 and 99 always correspond
     to 1900 through 1999.  MONTH is a month between 1 and 13.  DAY is a
     day between 0 and 31.  A DAY of 0 refers to the last day of the
     previous month, and a MONTH of 13 refers to the first month of the
     next year.  YEAR must be in range.  YEAR, MONTH, and DAY must all
     be integers.

     'YRMODA' results in the number of days between 15 Oct 1582 and the
     date specified, plus one.  The date passed to 'YRMODA' must be on
     or after 15 Oct 1582.  15 Oct 1582 has a value of 1.

 -- Function: VALUELABEL ( VARIABLE)
     Returns a string matching the label associated with the current
     value of VARIABLE.  If the current value of VARIABLE has no
     associated label, then this function returns the empty string.
     VARIABLE may be a numeric or string variable.


File: pspp.info,  Node: Statistical Distribution Functions,  Prev: Miscellaneous Functions,  Up: Functions

7.7.10 Statistical Distribution Functions
-----------------------------------------

PSPP can calculate several functions of standard statistical
distributions.  These functions are named systematically based on the
function and the distribution.  The table below describes the
statistical distribution functions in general:

PDF.DIST (X[, PARAM...])
     Probability density function for DIST.  The domain of X depends on
     DIST.  For continuous distributions, the result is the density of
     the probability function at X, and the range is nonnegative real
     numbers.  For discrete distributions, the result is the probability
     of X.

CDF.DIST (X[, PARAM...])
     Cumulative distribution function for DIST, that is, the probability
     that a random variate drawn from the distribution is less than X.
     The domain of X depends DIST.  The result is a probability.

SIG.DIST (X[, PARAM...)
     Tail probability function for DIST, that is, the probability that a
     random variate drawn from the distribution is greater than X.  The
     domain of X depends DIST.  The result is a probability.  Only a few
     distributions include an '/NAME/' function.

IDF.DIST (P[, PARAM...])
     Inverse distribution function for DIST, the value of X for which
     the CDF would yield P.  The value of P is a probability.  The range
     depends on DIST and is identical to the domain for the
     corresponding CDF.

RV.DIST ([PARAM...])
     Random variate function for DIST.  The range depends on the
     distribution.

NPDF.DIST (X[, PARAM...])
     Noncentral probability density function.  The result is the density
     of the given noncentral distribution at X.  The domain of X depends
     on DIST.  The range is nonnegative real numbers.  Only a few
     distributions include an '/NAME/' function.

NCDF.DIST (X[, PARAM...])
     Noncentral cumulative distribution function for DIST, that is, the
     probability that a random variate drawn from the given noncentral
     distribution is less than X.  The domain of X depends DIST.  The
     result is a probability.  Only a few distributions include an NCDF
     function.

   The individual distributions are described individually below.

* Menu:

* Continuous Distributions::    
* Discrete Distributions::      


File: pspp.info,  Node: Continuous Distributions,  Next: Discrete Distributions,  Up: Statistical Distribution Functions

7.7.10.1 Continuous Distributions
.................................

The following continuous distributions are available:

 -- Function: PDF.BETA (X)
 -- Function: CDF.BETA (X, A, B)
 -- Function: IDF.BETA (P, A, B)
 -- Function: RV.BETA (A, B)
 -- Function: NPDF.BETA (X, A, B, LAMBDA)
 -- Function: NCDF.BETA (X, A, B, LAMBDA)
     Beta distribution with shape parameters A and B.  The noncentral
     distribution takes an additional parameter LAMBDA.  Constraints: A
     > 0, B > 0, LAMBDA >= 0, 0 <= X <= 1, 0 <= P <= 1.

 -- Function: PDF.BVNOR (X0, X1, RHO)
 -- Function: CDF.VBNOR (X0, X1, RHO)
     Bivariate normal distribution of two standard normal variables with
     correlation coefficient RHO.  Two variates X0 and X1 must be
     provided.  Constraints: 0 <= RHO <= 1, 0 <= P <= 1.

 -- Function: PDF.CAUCHY (X, A, B)
 -- Function: CDF.CAUCHY (X, A, B)
 -- Function: IDF.CAUCHY (P, A, B)
 -- Function: RV.CAUCHY (A, B)
     Cauchy distribution with location parameter A and scale parameter
     B.  Constraints: B > 0, 0 < P < 1.

 -- Function: CDF.CHISQ (X, DF)
 -- Function: SIG.CHISQ (X, DF)
 -- Function: IDF.CHISQ (P, DF)
 -- Function: RV.CHISQ (DF)
 -- Function: NCDF.CHISQ (X, DF, LAMBDA)
     Chi-squared distribution with DF degrees of freedom.  The
     noncentral distribution takes an additional parameter LAMBDA.
     Constraints: DF > 0, LAMBDA > 0, X >= 0, 0 <= P < 1.

 -- Function: PDF.EXP (X, A)
 -- Function: CDF.EXP (X, A)
 -- Function: IDF.EXP (P, A)
 -- Function: RV.EXP (A)
     Exponential distribution with scale parameter A.  The inverse of A
     represents the rate of decay.  Constraints: A > 0, X >= 0, 0 <= P <
     1.

 -- Function: PDF.XPOWER (X, A, B)
 -- Function: RV.XPOWER (A, B)
     Exponential power distribution with positive scale parameter A and
     nonnegative power parameter B.  Constraints: A > 0, B >= 0, X >= 0,
     0 <= P <= 1.  This distribution is a PSPP extension.

 -- Function: PDF.F (X, DF1, DF2)
 -- Function: CDF.F (X, DF1, DF2)
 -- Function: SIG.F (X, DF1, DF2)
 -- Function: IDF.F (P, DF1, DF2)
 -- Function: RV.F (DF1, DF2)
     F-distribution of two chi-squared deviates with DF1 and DF2 degrees
     of freedom.  The noncentral distribution takes an additional
     parameter LAMBDA.  Constraints: DF1 > 0, DF2 > 0, LAMBDA >= 0, X >=
     0, 0 <= P < 1.

 -- Function: PDF.GAMMA (X, A, B)
 -- Function: CDF.GAMMA (X, A, B)
 -- Function: IDF.GAMMA (P, A, B)
 -- Function: RV.GAMMA (A, B)
     Gamma distribution with shape parameter A and scale parameter B.
     Constraints: A > 0, B > 0, X >= 0, 0 <= P < 1.

 -- Function: PDF.LANDAU (X)
 -- Function: RV.LANDAU ()
     Landau distribution.

 -- Function: PDF.LAPLACE (X, A, B)
 -- Function: CDF.LAPLACE (X, A, B)
 -- Function: IDF.LAPLACE (P, A, B)
 -- Function: RV.LAPLACE (A, B)
     Laplace distribution with location parameter A and scale parameter
     B.  Constraints: B > 0, 0 < P < 1.

 -- Function: RV.LEVY (C, ALPHA)
     Levy symmetric alpha-stable distribution with scale C and exponent
     ALPHA.  Constraints: 0 < ALPHA <= 2.

 -- Function: RV.LVSKEW (C, ALPHA, BETA)
     Levy skew alpha-stable distribution with scale C, exponent ALPHA,
     and skewness parameter BETA.  Constraints: 0 < ALPHA <= 2, -1 <=
     BETA <= 1.

 -- Function: PDF.LOGISTIC (X, A, B)
 -- Function: CDF.LOGISTIC (X, A, B)
 -- Function: IDF.LOGISTIC (P, A, B)
 -- Function: RV.LOGISTIC (A, B)
     Logistic distribution with location parameter A and scale parameter
     B.  Constraints: B > 0, 0 < P < 1.

 -- Function: PDF.LNORMAL (X, A, B)
 -- Function: CDF.LNORMAL (X, A, B)
 -- Function: IDF.LNORMAL (P, A, B)
 -- Function: RV.LNORMAL (A, B)
     Lognormal distribution with parameters A and B.  Constraints: A >
     0, B > 0, X >= 0, 0 <= P < 1.

 -- Function: PDF.NORMAL (X, MU, SIGMA)
 -- Function: CDF.NORMAL (X, MU, SIGMA)
 -- Function: IDF.NORMAL (P, MU, SIGMA)
 -- Function: RV.NORMAL (MU, SIGMA)
     Normal distribution with mean MU and standard deviation SIGMA.
     Constraints: B > 0, 0 < P < 1.  Three additional functions are
     available as shorthand:

      -- Function: CDFNORM (X)
          Equivalent to CDF.NORMAL(X, 0, 1).

      -- Function: PROBIT (P)
          Equivalent to IDF.NORMAL(P, 0, 1).

      -- Function: NORMAL (SIGMA)
          Equivalent to RV.NORMAL(0, SIGMA).

 -- Function: PDF.NTAIL (X, A, SIGMA)
 -- Function: RV.NTAIL (A, SIGMA)
     Normal tail distribution with lower limit A and standard deviation
     SIGMA.  This distribution is a PSPP extension.  Constraints: A > 0,
     X > A, 0 < P < 1.

 -- Function: PDF.PARETO (X, A, B)
 -- Function: CDF.PARETO (X, A, B)
 -- Function: IDF.PARETO (P, A, B)
 -- Function: RV.PARETO (A, B)
     Pareto distribution with threshold parameter A and shape parameter
     B.  Constraints: A > 0, B > 0, X >= A, 0 <= P < 1.

 -- Function: PDF.RAYLEIGH (X, SIGMA)
 -- Function: CDF.RAYLEIGH (X, SIGMA)
 -- Function: IDF.RAYLEIGH (P, SIGMA)
 -- Function: RV.RAYLEIGH (SIGMA)
     Rayleigh distribution with scale parameter SIGMA.  This
     distribution is a PSPP extension.  Constraints: SIGMA > 0, X > 0.

 -- Function: PDF.RTAIL (X, A, SIGMA)
 -- Function: RV.RTAIL (A, SIGMA)
     Rayleigh tail distribution with lower limit A and scale parameter
     SIGMA.  This distribution is a PSPP extension.  Constraints: A > 0,
     SIGMA > 0, X > A.

 -- Function: PDF.T (X, DF)
 -- Function: CDF.T (X, DF)
 -- Function: IDF.T (P, DF)
 -- Function: RV.T (DF)
     T-distribution with DF degrees of freedom.  The noncentral
     distribution takes an additional parameter LAMBDA.  Constraints: DF
     > 0, 0 < P < 1.

 -- Function: PDF.T1G (X, A, B)
 -- Function: CDF.T1G (X, A, B)
 -- Function: IDF.T1G (P, A, B)
     Type-1 Gumbel distribution with parameters A and B.  This
     distribution is a PSPP extension.  Constraints: 0 < P < 1.

 -- Function: PDF.T2G (X, A, B)
 -- Function: CDF.T2G (X, A, B)
 -- Function: IDF.T2G (P, A, B)
     Type-2 Gumbel distribution with parameters A and B.  This
     distribution is a PSPP extension.  Constraints: X > 0, 0 < P < 1.

 -- Function: PDF.UNIFORM (X, A, B)
 -- Function: CDF.UNIFORM (X, A, B)
 -- Function: IDF.UNIFORM (P, A, B)
 -- Function: RV.UNIFORM (A, B)
     Uniform distribution with parameters A and B.  Constraints: A <= X
     <= B, 0 <= P <= 1.  An additional function is available as
     shorthand:

      -- Function: UNIFORM (B)
          Equivalent to RV.UNIFORM(0, B).

 -- Function: PDF.WEIBULL (X, A, B)
 -- Function: CDF.WEIBULL (X, A, B)
 -- Function: IDF.WEIBULL (P, A, B)
 -- Function: RV.WEIBULL (A, B)
     Weibull distribution with parameters A and B.  Constraints: A > 0,
     B > 0, X >= 0, 0 <= P < 1.


File: pspp.info,  Node: Discrete Distributions,  Prev: Continuous Distributions,  Up: Statistical Distribution Functions

7.7.10.2 Discrete Distributions
...............................

The following discrete distributions are available:

 -- Function: PDF.BERNOULLI (X)
 -- Function: CDF.BERNOULLI (X, P)
 -- Function: RV.BERNOULLI (P)
     Bernoulli distribution with probability of success P.  Constraints:
     X = 0 or 1, 0 <= P <= 1.

 -- Function: PDF.BINOM (X, N, P)
 -- Function: CDF.BINOM (X, N, P)
 -- Function: RV.BINOM (N, P)
     Binomial distribution with N trials and probability of success P.
     Constraints: integer N > 0, 0 <= P <= 1, integer X <= N.

 -- Function: PDF.GEOM (X, N, P)
 -- Function: CDF.GEOM (X, N, P)
 -- Function: RV.GEOM (N, P)
     Geometric distribution with probability of success P.  Constraints:
     0 <= P <= 1, integer X > 0.

 -- Function: PDF.HYPER (X, A, B, C)
 -- Function: CDF.HYPER (X, A, B, C)
 -- Function: RV.HYPER (A, B, C)
     Hypergeometric distribution when B objects out of A are drawn and C
     of the available objects are distinctive.  Constraints: integer A >
     0, integer B <= A, integer C <= A, integer X >= 0.

 -- Function: PDF.LOG (X, P)
 -- Function: RV.LOG (P)
     Logarithmic distribution with probability parameter P.
     Constraints: 0 <= P < 1, X >= 1.

 -- Function: PDF.NEGBIN (X, N, P)
 -- Function: CDF.NEGBIN (X, N, P)
 -- Function: RV.NEGBIN (N, P)
     Negative binomial distribution with number of successes parameter N
     and probability of success parameter P.  Constraints: integer N >=
     0, 0 < P <= 1, integer X >= 1.

 -- Function: PDF.POISSON (X, MU)
 -- Function: CDF.POISSON (X, MU)
 -- Function: RV.POISSON (MU)
     Poisson distribution with mean MU.  Constraints: MU > 0, integer X
     >= 0.


File: pspp.info,  Node: Order of Operations,  Prev: Functions,  Up: Expressions

7.8 Operator Precedence
=======================

The following table describes operator precedence.  Smaller-numbered
levels in the table have higher precedence.  Within a level, operations
are always performed from left to right.  The first occurrence of '-'
represents unary negation, the second binary subtraction.

  1. '( )'
  2. '**'
  3. '-'
  4. '* /'
  5. '+ -'
  6. 'EQ GE GT LE LT NE'
  7. 'AND NOT OR'


File: pspp.info,  Node: Data Input and Output,  Next: System and Portable File IO,  Prev: Expressions,  Up: Top

8 Data Input and Output
***********************

Data are the focus of the PSPP language.  Each datum belongs to a "case"
(also called an "observation").  Each case represents an individual or
"experimental unit".  For example, in the results of a survey, the names
of the respondents, their sex, age, etc. and their responses are all
data and the data pertaining to single respondent is a case.  This
chapter examines the PSPP commands for defining variables and reading
and writing data.  There are alternative commands to read data from
predefined sources such as system files or databases (*Note GET DATA:
GET.)

     Note: These commands tell PSPP how to read data, but the data will
     not actually be read until a procedure is executed.

* Menu:

* BEGIN DATA::                  Embed data within a syntax file.
* CLOSE FILE HANDLE::           Close a file handle.
* DATAFILE ATTRIBUTE::          Set custom attributes on data files.
* DATASET::                     Manage multiple datasets.
* DATA LIST::                   Fundamental data reading command.
* END CASE::                    Output the current case.
* END FILE::                    Terminate the current input program.
* FILE HANDLE::                 Support for special file formats.
* INPUT PROGRAM::               Support for complex input programs.
* LIST::                        List cases in the active dataset.
* NEW FILE::                    Clear the active dataset.
* PRINT::                       Display values in print formats.
* PRINT EJECT::                 Eject the current page then print.
* PRINT SPACE::                 Print blank lines.
* REREAD::                      Take another look at the previous input line.
* REPEATING DATA::              Multiple cases on a single line.
* WRITE::                       Display values in write formats.


File: pspp.info,  Node: BEGIN DATA,  Next: CLOSE FILE HANDLE,  Up: Data Input and Output

8.1 BEGIN DATA
==============

     BEGIN DATA.
     ...
     END DATA.

   'BEGIN DATA' and 'END DATA' can be used to embed raw ASCII data in a
PSPP syntax file.  'DATA LIST' or another input procedure must be used
before 'BEGIN DATA' (*note DATA LIST::).  'BEGIN DATA' and 'END DATA'
must be used together.  'END DATA' must appear by itself on a single
line, with no leading white space and exactly one space between the
words 'END' and 'DATA', like this:

     END DATA.


File: pspp.info,  Node: CLOSE FILE HANDLE,  Next: DATAFILE ATTRIBUTE,  Prev: BEGIN DATA,  Up: Data Input and Output

8.2 CLOSE FILE HANDLE
=====================

     CLOSE FILE HANDLE HANDLE_NAME.

   'CLOSE FILE HANDLE' disassociates the name of a file handle with a
given file.  The only specification is the name of the handle to close.
Afterward 'FILE HANDLE'.

   The file named INLINE, which represents data entered between 'BEGIN
DATA' and 'END DATA', cannot be closed.  Attempts to close it with
'CLOSE FILE HANDLE' have no effect.

   'CLOSE FILE HANDLE' is a PSPP extension.


File: pspp.info,  Node: DATAFILE ATTRIBUTE,  Next: DATASET,  Prev: CLOSE FILE HANDLE,  Up: Data Input and Output

8.3 DATAFILE ATTRIBUTE
======================

     DATAFILE ATTRIBUTE
              ATTRIBUTE=NAME('VALUE') [NAME('VALUE')]...
              ATTRIBUTE=NAME[INDEX]('VALUE') [NAME[INDEX]('VALUE')]...
              DELETE=NAME [NAME]...
              DELETE=NAME[INDEX] [NAME[INDEX]]...

   'DATAFILE ATTRIBUTE' adds, modifies, or removes user-defined
attributes associated with the active dataset.  Custom data file
attributes are not interpreted by PSPP, but they are saved as part of
system files and may be used by other software that reads them.

   Use the 'ATTRIBUTE' subcommand to add or modify a custom data file
attribute.  Specify the name of the attribute as an identifier (*note
Tokens::), followed by the desired value, in parentheses, as a quoted
string.  Attribute names that begin with '$' are reserved for PSPP's
internal use, and attribute names that begin with '@' or '$@' are not
displayed by most PSPP commands that display other attributes.  Other
attribute names are not treated specially.

   Attributes may also be organized into arrays.  To assign to an array
element, add an integer array index enclosed in square brackets ('[' and
']') between the attribute name and value.  Array indexes start at 1,
not 0.  An attribute array that has a single element (number 1) is not
distinguished from a non-array attribute.

   Use the 'DELETE' subcommand to delete an attribute.  Specify an
attribute name by itself to delete an entire attribute, including all
array elements for attribute arrays.  Specify an attribute name followed
by an array index in square brackets to delete a single element of an
attribute array.  In the latter case, all the array elements numbered
higher than the deleted element are shifted down, filling the vacated
position.

   To associate custom attributes with particular variables, instead of
with the entire active dataset, use 'VARIABLE ATTRIBUTE' (*note VARIABLE
ATTRIBUTE::) instead.

   'DATAFILE ATTRIBUTE' takes effect immediately.  It is not affected by
conditional and looping structures such as 'DO IF' or 'LOOP'.


File: pspp.info,  Node: DATASET,  Next: DATA LIST,  Prev: DATAFILE ATTRIBUTE,  Up: Data Input and Output

8.4 DATASET commands
====================

     DATASET NAME NAME [WINDOW={ASIS,FRONT}].
     DATASET ACTIVATE NAME [WINDOW={ASIS,FRONT}].
     DATASET COPY NAME [WINDOW={MINIMIZED,HIDDEN,FRONT}].
     DATASET DECLARE NAME [WINDOW={MINIMIZED,HIDDEN,FRONT}].
     DATASET CLOSE {NAME,*,ALL}.
     DATASET DISPLAY.

   The 'DATASET' commands simplify use of multiple datasets within a
PSPP session.  They allow datasets to be created and destroyed.  At any
given time, most PSPP commands work with a single dataset, called the
active dataset.

   The DATASET NAME command gives the active dataset the specified name,
or if it already had a name, it renames it.  If another dataset already
had the given name, that dataset is deleted.

   The DATASET ACTIVATE command selects the named dataset, which must
already exist, as the active dataset.  Before switching the active
dataset, any pending transformations are executed, as if 'EXECUTE' had
been specified.  If the active dataset is unnamed before switching, then
it is deleted and becomes unavailable after switching.

   The DATASET COPY command creates a new dataset with the specified
name, whose contents are a copy of the active dataset.  Any pending
transformations are executed, as if 'EXECUTE' had been specified, before
making the copy.  If a dataset with the given name already exists, it is
replaced.  If the name is the name of the active dataset, then the
active dataset becomes unnamed.

   The DATASET DECLARE command creates a new dataset that is initially
"empty," that is, it has no dictionary or data.  If a dataset with the
given name already exists, this has no effect.  The new dataset can be
used with commands that support output to a dataset, e.g.  AGGREGATE
(*note AGGREGATE::).

   The DATASET CLOSE command deletes a dataset.  If the active dataset
is specified by name, or if '*' is specified, then the active dataset
becomes unnamed.  If a different dataset is specified by name, then it
is deleted and becomes unavailable.  Specifying ALL deletes all datasets
except for the active dataset, which becomes unnamed.

   The DATASET DISPLAY command lists all the currently defined datasets.

   Many DATASET commands accept an optional 'WINDOW' subcommand.  In the
PSPPIRE GUI, the value given for this subcommand influences how the
dataset's window is displayed.  Outside the GUI, the 'WINDOW' subcommand
has no effect.  The valid values are:

ASIS
     Do not change how the window is displayed.  This is the default for
     DATASET NAME and DATASET ACTIVATE.

FRONT
     Raise the dataset's window to the top.  Make it the default dataset
     for running syntax.

MINIMIZED
     Display the window "minimized" to an icon.  Prefer other datasets
     for running syntax.  This is the default for DATASET COPY and
     DATASET DECLARE.

HIDDEN
     Hide the dataset's window.  Prefer other datasets for running
     syntax.


File: pspp.info,  Node: DATA LIST,  Next: END CASE,  Prev: DATASET,  Up: Data Input and Output

8.5 DATA LIST
=============

Used to read text or binary data, 'DATA LIST' is the most fundamental
data-reading command.  Even the more sophisticated input methods use
'DATA LIST' commands as a building block.  Understanding 'DATA LIST' is
important to understanding how to use PSPP to read your data files.

   There are two major variants of 'DATA LIST', which are fixed format
and free format.  In addition, free format has a minor variant, list
format, which is discussed in terms of its differences from vanilla free
format.

   Each form of 'DATA LIST' is described in detail below.

   *Note GET DATA::, for a command that offers a few enhancements over
DATA LIST and that may be substituted for DATA LIST in many situations.

* Menu:

* DATA LIST FIXED::             Fixed columnar locations for data.
* DATA LIST FREE::              Any spacing you like.
* DATA LIST LIST::              Each case must be on a single line.


File: pspp.info,  Node: DATA LIST FIXED,  Next: DATA LIST FREE,  Up: DATA LIST

8.5.1 DATA LIST FIXED
---------------------

     DATA LIST [FIXED]
             {TABLE,NOTABLE}
             [FILE='FILE_NAME' [ENCODING='ENCODING']]
             [RECORDS=RECORD_COUNT]
             [END=END_VAR]
             [SKIP=RECORD_COUNT]
             /[line_no] VAR_SPEC...

     where each VAR_SPEC takes one of the forms
             VAR_LIST START-END [TYPE_SPEC]
             VAR_LIST (FORTRAN_SPEC)

   'DATA LIST FIXED' is used to read data files that have values at
fixed positions on each line of single-line or multiline records.  The
keyword FIXED is optional.

   The 'FILE' subcommand must be used if input is to be taken from an
external file.  It may be used to specify a file name as a string or a
file handle (*note File Handles::).  If the 'FILE' subcommand is not
used, then input is assumed to be specified within the command file
using 'BEGIN DATA'...'END DATA' (*note BEGIN DATA::).  The 'ENCODING'
subcommand may only be used if the 'FILE' subcommand is also used.  It
specifies the character encoding of the file.  *Note INSERT::, for
information on supported encodings.

   The optional 'RECORDS' subcommand, which takes a single integer as an
argument, is used to specify the number of lines per record.  If
'RECORDS' is not specified, then the number of lines per record is
calculated from the list of variable specifications later in 'DATA
LIST'.

   The 'END' subcommand is only useful in conjunction with 'INPUT
PROGRAM'.  *Note INPUT PROGRAM::, for details.

   The optional 'SKIP' subcommand specifies a number of records to skip
at the beginning of an input file.  It can be used to skip over a row
that contains variable names, for example.

   'DATA LIST' can optionally output a table describing how the data
file will be read.  The 'TABLE' subcommand enables this output, and
'NOTABLE' disables it.  The default is to output the table.

   The list of variables to be read from the data list must come last.
Each line in the data record is introduced by a slash ('/').
Optionally, a line number may follow the slash.  Following, any number
of variable specifications may be present.

   Each variable specification consists of a list of variable names
followed by a description of their location on the input line.  Sets of
variables may be specified using the 'DATA LIST' 'TO' convention (*note
Sets of Variables::).  There are two ways to specify the location of the
variable on the line: columnar style and FORTRAN style.

   In columnar style, the starting column and ending column for the
field are specified after the variable name, separated by a dash ('-').
For instance, the third through fifth columns on a line would be
specified '3-5'.  By default, variables are considered to be in 'F'
format (*note Input and Output Formats::).  (This default can be
changed; see *note SET:: for more information.)

   In columnar style, to use a variable format other than the default,
specify the format type in parentheses after the column numbers.  For
instance, for alphanumeric 'A' format, use '(A)'.

   In addition, implied decimal places can be specified in parentheses
after the column numbers.  As an example, suppose that a data file has a
field in which the characters '1234' should be interpreted as having the
value 12.34.  Then this field has two implied decimal places, and the
corresponding specification would be '(2)'.  If a field that has implied
decimal places contains a decimal point, then the implied decimal places
are not applied.

   Changing the variable format and adding implied decimal places can be
done together; for instance, '(N,5)'.

   When using columnar style, the input and output width of each
variable is computed from the field width.  The field width must be
evenly divisible into the number of variables specified.

   FORTRAN style is an altogether different approach to specifying field
locations.  With this approach, a list of variable input format
specifications, separated by commas, are placed after the variable names
inside parentheses.  Each format specifier advances as many characters
into the input line as it uses.

   Implied decimal places also exist in FORTRAN style.  A format
specification with D decimal places also has D implied decimal places.

   In addition to the standard format specifiers (*note Input and Output
Formats::), FORTRAN style defines some extensions:

'X'
     Advance the current column on this line by one character position.

'T'X
     Set the current column on this line to column X, with column
     numbers considered to begin with 1 at the left margin.

'NEWREC'X
     Skip forward X lines in the current record, resetting the active
     column to the left margin.

Repeat count
     Any format specifier may be preceded by a number.  This causes the
     action of that format specifier to be repeated the specified number
     of times.

(SPEC1, ..., SPECN)
     Group the given specifiers together.  This is most useful when
     preceded by a repeat count.  Groups may be nested arbitrarily.

   FORTRAN and columnar styles may be freely intermixed.  Columnar style
leaves the active column immediately after the ending column specified.
Record motion using 'NEWREC' in FORTRAN style also applies to later
FORTRAN and columnar specifiers.

* Menu:

* DATA LIST FIXED Examples::    Examples of DATA LIST FIXED.


File: pspp.info,  Node: DATA LIST FIXED Examples,  Up: DATA LIST FIXED

Examples
........

  1.      DATA LIST TABLE /NAME 1-10 (A) INFO1 TO INFO3 12-17 (1).

          BEGIN DATA.
          John Smith 102311
          Bob Arnold 122015
          Bill Yates  918 6
          END DATA.

     Defines the following variables:

        * 'NAME', a 10-character-wide string variable, in columns 1
          through 10.

        * 'INFO1', a numeric variable, in columns 12 through 13.

        * 'INFO2', a numeric variable, in columns 14 through 15.

        * 'INFO3', a numeric variable, in columns 16 through 17.

     The 'BEGIN DATA'/'END DATA' commands cause three cases to be
     defined:

          Case   NAME         INFO1   INFO2   INFO3
             1   John Smith     10      23      11
             2   Bob Arnold     12      20      15
             3   Bill Yates      9      18       6

     The 'TABLE' keyword causes PSPP to print out a table describing the
     four variables defined.

  2.      DAT LIS FIL="survey.dat"
                  /ID 1-5 NAME 7-36 (A) SURNAME 38-67 (A) MINITIAL 69 (A)
                  /Q01 TO Q50 7-56
                  /.

     Defines the following variables:

        * 'ID', a numeric variable, in columns 1-5 of the first record.

        * 'NAME', a 30-character string variable, in columns 7-36 of the
          first record.

        * 'SURNAME', a 30-character string variable, in columns 38-67 of
          the first record.

        * 'MINITIAL', a 1-character string variable, in column 69 of the
          first record.

        * Fifty variables 'Q01', 'Q02', 'Q03', ..., 'Q49', 'Q50', all
          numeric, 'Q01' in column 7, 'Q02' in column 8, ..., 'Q49' in
          column 55, 'Q50' in column 56, all in the second record.

     Cases are separated by a blank record.

     Data is read from file 'survey.dat' in the current directory.

     This example shows keywords abbreviated to their first 3 letters.


File: pspp.info,  Node: DATA LIST FREE,  Next: DATA LIST LIST,  Prev: DATA LIST FIXED,  Up: DATA LIST

8.5.2 DATA LIST FREE
--------------------

     DATA LIST FREE
             [({TAB,'C'}, ...)]
             [{NOTABLE,TABLE}]
             [FILE='FILE_NAME' [ENCODING='ENCODING']]
             [SKIP=RECORD_CNT]
             /VAR_SPEC...

     where each VAR_SPEC takes one of the forms
             VAR_LIST [(TYPE_SPEC)]
             VAR_LIST *

   In free format, the input data is, by default, structured as a series
of fields separated by spaces, tabs, or line breaks.  If the current
'DECIMAL' separator is 'DOT' (*note SET::), then commas are also treated
as field separators.  Each field's content may be unquoted, or it may be
quoted with a pairs of apostrophes (''') or double quotes ('"').
Unquoted white space separates fields but is not part of any field.  Any
mix of spaces, tabs, and line breaks is equivalent to a single space for
the purpose of separating fields, but consecutive commas will skip a
field.

   Alternatively, delimiters can be specified explicitly, as a
parenthesized, comma-separated list of single-character strings
immediately following FREE. The word TAB may also be used to specify a
tab character as a delimiter.  When delimiters are specified explicitly,
only the given characters, plus line breaks, separate fields.
Furthermore, leading spaces at the beginnings of fields are not trimmed,
consecutive delimiters define empty fields, and no form of quoting is
allowed.

   The 'NOTABLE' and 'TABLE' subcommands are as in 'DATA LIST FIXED'
above.  'NOTABLE' is the default.

   The 'FILE', 'SKIP', and 'ENCODING' subcommands are as in 'DATA LIST
FIXED' above.

   The variables to be parsed are given as a single list of variable
names.  This list must be introduced by a single slash ('/').  The set
of variable names may contain format specifications in parentheses
(*note Input and Output Formats::).  Format specifications apply to all
variables back to the previous parenthesized format specification.

   In addition, an asterisk may be used to indicate that all variables
preceding it are to have input/output format 'F8.0'.

   Specified field widths are ignored on input, although all normal
limits on field width apply, but they are honored on output.


File: pspp.info,  Node: DATA LIST LIST,  Prev: DATA LIST FREE,  Up: DATA LIST

8.5.3 DATA LIST LIST
--------------------

     DATA LIST LIST
             [({TAB,'C'}, ...)]
             [{NOTABLE,TABLE}]
             [FILE='FILE_NAME' [ENCODING='ENCODING']]
             [SKIP=RECORD_COUNT]
             /VAR_SPEC...

     where each VAR_SPEC takes one of the forms
             VAR_LIST [(TYPE_SPEC)]
             VAR_LIST *

   With one exception, 'DATA LIST LIST' is syntactically and
semantically equivalent to 'DATA LIST FREE'.  The exception is that each
input line is expected to correspond to exactly one input record.  If
more or fewer fields are found on an input line than expected, an
appropriate diagnostic is issued.


File: pspp.info,  Node: END CASE,  Next: END FILE,  Prev: DATA LIST,  Up: Data Input and Output

8.6 END CASE
============

     END CASE.

   'END CASE' is used only within 'INPUT PROGRAM' to output the current
case.  *Note INPUT PROGRAM::, for details.


File: pspp.info,  Node: END FILE,  Next: FILE HANDLE,  Prev: END CASE,  Up: Data Input and Output

8.7 END FILE
============

     END FILE.

   'END FILE' is used only within 'INPUT PROGRAM' to terminate the
current input program.  *Note INPUT PROGRAM::.


File: pspp.info,  Node: FILE HANDLE,  Next: INPUT PROGRAM,  Prev: END FILE,  Up: Data Input and Output

8.8 FILE HANDLE
===============

     For text files:
             FILE HANDLE HANDLE_NAME
                     /NAME='FILE_NAME
                     [/MODE=CHARACTER]
                     [/ENDS={CR,CRLF}]
                     /TABWIDTH=TAB_WIDTH
                     [ENCODING='ENCODING']

     For binary files in native encoding with fixed-length records:
             FILE HANDLE HANDLE_NAME
                     /NAME='FILE_NAME'
                     /MODE=IMAGE
                     [/LRECL=REC_LEN]
                     [ENCODING='ENCODING']

     For binary files in native encoding with variable-length records:
             FILE HANDLE HANDLE_NAME
                     /NAME='FILE_NAME'
                     /MODE=BINARY
                     [/LRECL=REC_LEN]
                     [ENCODING='ENCODING']

     For binary files encoded in EBCDIC:
             FILE HANDLE HANDLE_NAME
                     /NAME='FILE_NAME'
                     /MODE=360
                     /RECFORM={FIXED,VARIABLE,SPANNED}
                     [/LRECL=REC_LEN]
                     [ENCODING='ENCODING']

   Use 'FILE HANDLE' to associate a file handle name with a file and its
attributes, so that later commands can refer to the file by its handle
name.  Names of text files can be specified directly on commands that
access files, so that 'FILE HANDLE' is only needed when a file is not an
ordinary file containing lines of text.  However, 'FILE HANDLE' may be
used even for text files, and it may be easier to specify a file's name
once and later refer to it by an abstract handle.

   Specify the file handle name as the identifier immediately following
the 'FILE HANDLE' command name.  The identifier INLINE is reserved for
representing data embedded in the syntax file (*note BEGIN DATA::) The
file handle name must not already have been used in a previous
invocation of 'FILE HANDLE', unless it has been closed by an intervening
command (*note CLOSE FILE HANDLE::).

   The effect and syntax of 'FILE HANDLE' depends on the selected MODE:

   * In CHARACTER mode, the default, the data file is read as a text
     file.  Each text line is read as one record.

     In CHARACTER mode only, tabs are expanded to spaces by input
     programs, except by 'DATA LIST FREE' with explicitly specified
     delimiters.  Each tab is 4 characters wide by default, but TABWIDTH
     (a PSPP extension) may be used to specify an alternate width.  Use
     a TABWIDTH of 0 to suppress tab expansion.

     A file written in CHARACTER mode by default uses the line ends of
     the system on which PSPP is running, that is, on Windows, the
     default is CR LF line ends, and on other systems the default is LF
     only.  Specify ENDS as CR or CRLF to override the default.  PSPP
     reads files using either convention on any kind of system,
     regardless of ENDS.

   * In IMAGE mode, the data file is treated as a series of fixed-length
     binary records.  LRECL should be used to specify the record length
     in bytes, with a default of 1024.  On input, it is an error if an
     IMAGE file's length is not a integer multiple of the record length.
     On output, each record is padded with spaces or truncated, if
     necessary, to make it exactly the correct length.

   * In BINARY mode, the data file is treated as a series of
     variable-length binary records.  LRECL may be specified, but its
     value is ignored.  The data for each record is both preceded and
     followed by a 32-bit signed integer in little-endian byte order
     that specifies the length of the record.  (This redundancy permits
     records in these files to be efficiently read in reverse order,
     although PSPP always reads them in forward order.)  The length does
     not include either integer.

   * Mode 360 reads and writes files in formats first used for tapes in
     the 1960s on IBM mainframe operating systems and still supported
     today by the modern successors of those operating systems.  For
     more information, see 'OS/400 Tape and Diskette Device
     Programming', available on IBM's website.

     Alphanumeric data in mode 360 files are encoded in EBCDIC. PSPP
     translates EBCDIC to or from the host's native format as necessary
     on input or output, using an ASCII/EBCDIC translation that is
     one-to-one, so that a "round trip" from ASCII to EBCDIC back to
     ASCII, or vice versa, always yields exactly the original data.

     The 'RECFORM' subcommand is required in mode 360.  The precise file
     format depends on its setting:

     F
     FIXED
          This record format is equivalent to IMAGE mode, except for
          EBCDIC translation.

          IBM documentation calls this '*F' (fixed-length, deblocked)
          format.

     V
     VARIABLE
          The file comprises a sequence of zero or more variable-length
          blocks.  Each block begins with a 4-byte "block descriptor
          word" (BDW). The first two bytes of the BDW are an unsigned
          integer in big-endian byte order that specifies the length of
          the block, including the BDW itself.  The other two bytes of
          the BDW are ignored on input and written as zeros on output.

          Following the BDW, the remainder of each block is a sequence
          of one or more variable-length records, each of which in turn
          begins with a 4-byte "record descriptor word" (RDW) that has
          the same format as the BDW. Following the RDW, the remainder
          of each record is the record data.

          The maximum length of a record in VARIABLE mode is 65,527
          bytes: 65,535 bytes (the maximum value of a 16-bit unsigned
          integer), minus 4 bytes for the BDW, minus 4 bytes for the
          RDW.

          In mode VARIABLE, LRECL specifies a maximum, not a fixed,
          record length, in bytes.  The default is 8,192.

          IBM documentation calls this '*VB' (variable-length, blocked,
          unspanned) format.

     VS
     SPANNED
          The file format is like that of VARIABLE mode, except that
          logical records may be split among multiple physical records
          (called "segments") or blocks.  In SPANNED mode, the third
          byte of each RDW is called the segment control character
          (SCC). Odd SCC values cause the segment to be appended to a
          record buffer maintained in memory; even values also append
          the segment and then flush its contents to the input
          procedure.  Canonically, SCC value 0 designates a record not
          spanned among multiple segments, and values 1 through 3
          designate the first segment, the last segment, or an
          intermediate segment, respectively, within a multi-segment
          record.  The record buffer is also flushed at end of file
          regardless of the final record's SCC.

          The maximum length of a logical record in VARIABLE mode is
          limited only by memory available to PSPP.  Segments are
          limited to 65,527 bytes, as in VARIABLE mode.

          This format is similar to what IBM documentation call '*VS'
          (variable-length, deblocked, spanned) format.

     In mode 360, fields of type A that extend beyond the end of a
     record read from disk are padded with spaces in the host's native
     character set, which are then translated from EBCDIC to the native
     character set.  Thus, when the host's native character set is based
     on ASCII, these fields are effectively padded with character
     'X'80''.  This wart is implemented for compatibility.

   The 'NAME' subcommand specifies the name of the file associated with
the handle.  It is required in all modes but SCRATCH mode, in which its
use is forbidden.

   The ENCODING subcommand specifies the encoding of text in the file.
For reading text files in CHARACTER mode, all of the forms described for
ENCODING on the INSERT command are supported (*note INSERT::).  For
reading in other file-based modes, encoding autodetection is not
supported; if the specified encoding requests autodetection then the
default encoding will be used.  This is also true when a file handle is
used for writing a file in any mode.


File: pspp.info,  Node: INPUT PROGRAM,  Next: LIST,  Prev: FILE HANDLE,  Up: Data Input and Output

8.9 INPUT PROGRAM
=================

     INPUT PROGRAM.
     ... input commands ...
     END INPUT PROGRAM.

   'INPUT PROGRAM'...'END INPUT PROGRAM' specifies a complex input
program.  By placing data input commands within 'INPUT PROGRAM', PSPP
programs can take advantage of more complex file structures than
available with only 'DATA LIST'.

   The first sort of extended input program is to simply put multiple
'DATA LIST' commands within the 'INPUT PROGRAM'.  This will cause all of
the data files to be read in parallel.  Input will stop when end of file
is reached on any of the data files.

   Transformations, such as conditional and looping constructs, can also
be included within 'INPUT PROGRAM'.  These can be used to combine input
from several data files in more complex ways.  However, input will still
stop when end of file is reached on any of the data files.

   To prevent 'INPUT PROGRAM' from terminating at the first end of file,
use the 'END' subcommand on 'DATA LIST'.  This subcommand takes a
variable name, which should be a numeric scratch variable (*note Scratch
Variables::).  (It need not be a scratch variable but otherwise the
results can be surprising.)  The value of this variable is set to 0 when
reading the data file, or 1 when end of file is encountered.

   Two additional commands are useful in conjunction with 'INPUT
PROGRAM'.  'END CASE' is the first.  Normally each loop through the
'INPUT PROGRAM' structure produces one case.  'END CASE' controls
exactly when cases are output.  When 'END CASE' is used, looping from
the end of 'INPUT PROGRAM' to the beginning does not cause a case to be
output.

   'END FILE' is the second.  When the 'END' subcommand is used on 'DATA
LIST', there is no way for the 'INPUT PROGRAM' construct to stop
looping, so an infinite loop results.  'END FILE', when executed, stops
the flow of input data and passes out of the 'INPUT PROGRAM' structure.

   'INPUT PROGRAM' must contain at least one 'DATA LIST' or 'END FILE'
command.

   All this is very confusing.  A few examples should help to clarify.

     INPUT PROGRAM.
             DATA LIST NOTABLE FILE='a.data'/X 1-10.
             DATA LIST NOTABLE FILE='b.data'/Y 1-10.
     END INPUT PROGRAM.
     LIST.

   The example above reads variable X from file 'a.data' and variable Y
from file 'b.data'.  If one file is shorter than the other then the
extra data in the longer file is ignored.

     INPUT PROGRAM.
             NUMERIC #A #B.

             DO IF NOT #A.
                     DATA LIST NOTABLE END=#A FILE='a.data'/X 1-10.
             END IF.
             DO IF NOT #B.
                     DATA LIST NOTABLE END=#B FILE='b.data'/Y 1-10.
             END IF.
             DO IF #A AND #B.
                     END FILE.
             END IF.
             END CASE.
     END INPUT PROGRAM.
     LIST.

   The above example reads variable X from 'a.data' and variable Y from
'b.data'.  If one file is shorter than the other then the missing field
is set to the system-missing value alongside the present value for the
remaining length of the longer file.

     INPUT PROGRAM.
             NUMERIC #A #B.

             DO IF #A.
                     DATA LIST NOTABLE END=#B FILE='b.data'/X 1-10.
                     DO IF #B.
                             END FILE.
                     ELSE.
                             END CASE.
                     END IF.
             ELSE.
                     DATA LIST NOTABLE END=#A FILE='a.data'/X 1-10.
                     DO IF NOT #A.
                             END CASE.
                     END IF.
             END IF.
     END INPUT PROGRAM.
     LIST.

   The above example reads data from file 'a.data', then from 'b.data',
and concatenates them into a single active dataset.

     INPUT PROGRAM.
             NUMERIC #EOF.

             LOOP IF NOT #EOF.
                     DATA LIST NOTABLE END=#EOF FILE='a.data'/X 1-10.
                     DO IF NOT #EOF.
                             END CASE.
                     END IF.
             END LOOP.

             COMPUTE #EOF = 0.
             LOOP IF NOT #EOF.
                     DATA LIST NOTABLE END=#EOF FILE='b.data'/X 1-10.
                     DO IF NOT #EOF.
                             END CASE.
                     END IF.
             END LOOP.

             END FILE.
     END INPUT PROGRAM.
     LIST.

   The above example does the same thing as the previous example, in a
different way.

     INPUT PROGRAM.
             LOOP #I=1 TO 50.
                     COMPUTE X=UNIFORM(10).
                     END CASE.
             END LOOP.
             END FILE.
     END INPUT PROGRAM.
     LIST/FORMAT=NUMBERED.

   The above example causes an active dataset to be created consisting
of 50 random variates between 0 and 10.


File: pspp.info,  Node: LIST,  Next: NEW FILE,  Prev: INPUT PROGRAM,  Up: Data Input and Output

8.10 LIST
=========

     LIST
             /VARIABLES=VAR_LIST
             /CASES=FROM START_INDEX TO END_INDEX BY INCR_INDEX
             /FORMAT={UNNUMBERED,NUMBERED} {WRAP,SINGLE}

   The 'LIST' procedure prints the values of specified variables to the
listing file.

   The 'VARIABLES' subcommand specifies the variables whose values are
to be printed.  Keyword VARIABLES is optional.  If 'VARIABLES'
subcommand is not specified then all variables in the active dataset are
printed.

   The 'CASES' subcommand can be used to specify a subset of cases to be
printed.  Specify 'FROM' and the case number of the first case to print,
'TO' and the case number of the last case to print, and 'BY' and the
number of cases to advance between printing cases, or any subset of
those settings.  If 'CASES' is not specified then all cases are printed.

   The 'FORMAT' subcommand can be used to change the output format.
'NUMBERED' will print case numbers along with each case; 'UNNUMBERED',
the default, causes the case numbers to be omitted.  The 'WRAP' and
'SINGLE' settings are currently not used.

   Case numbers start from 1.  They are counted after all
transformations have been considered.

   'LIST' is a procedure.  It causes the data to be read.


File: pspp.info,  Node: NEW FILE,  Next: PRINT,  Prev: LIST,  Up: Data Input and Output

8.11 NEW FILE
=============

     NEW FILE.

   'NEW FILE' command clears the dictionary and data from the current
active dataset.


File: pspp.info,  Node: PRINT,  Next: PRINT EJECT,  Prev: NEW FILE,  Up: Data Input and Output

8.12 PRINT
==========

     PRINT
             [OUTFILE='FILE_NAME']
             [RECORDS=N_LINES]
             [{NOTABLE,TABLE}]
             [ENCODING='ENCODING']
             [/[LINE_NO] ARG...]

     ARG takes one of the following forms:
             'STRING' [START]
             VAR_LIST START-END [TYPE_SPEC]
             VAR_LIST (FORTRAN_SPEC)
             VAR_LIST *

   The 'PRINT' transformation writes variable data to the listing file
or an output file.  'PRINT' is executed when a procedure causes the data
to be read.  Follow 'PRINT' by 'EXECUTE' to print variable data without
invoking a procedure (*note EXECUTE::).

   All 'PRINT' subcommands are optional.  If no strings or variables are
specified, 'PRINT' outputs a single blank line.

   The 'OUTFILE' subcommand specifies the file to receive the output.
The file may be a file name as a string or a file handle (*note File
Handles::).  If 'OUTFILE' is not present then output will be sent to
PSPP's output listing file.  When 'OUTFILE' is present, a space is
inserted at beginning of each output line, even lines that otherwise
would be blank.

   The 'ENCODING' subcommand may only be used if the 'OUTFILE'
subcommand is also used.  It specifies the character encoding of the
file.  *Note INSERT::, for information on supported encodings.

   The 'RECORDS' subcommand specifies the number of lines to be output.
The number of lines may optionally be surrounded by parentheses.

   'TABLE' will cause the 'PRINT' command to output a table to the
listing file that describes what it will print to the output file.
'NOTABLE', the default, suppresses this output table.

   Introduce the strings and variables to be printed with a slash ('/').
Optionally, the slash may be followed by a number indicating which
output line will be specified.  In the absence of this line number, the
next line number will be specified.  Multiple lines may be specified
using multiple slashes with the intended output for a line following its
respective slash.

   Literal strings may be printed.  Specify the string itself.
Optionally the string may be followed by a column number, specifying the
column on the line where the string should start.  Otherwise, the string
will be printed at the current position on the line.

   Variables to be printed can be specified in the same ways as
available for 'DATA LIST FIXED' (*note DATA LIST FIXED::).  In addition,
a variable list may be followed by an asterisk ('*'), which indicates
that the variables should be printed in their dictionary print formats,
separated by spaces.  A variable list followed by a slash or the end of
command will be interpreted the same way.

   If a FORTRAN type specification is used to move backwards on the
current line, then text is written at that point on the line, the line
will be truncated to that length, although additional text being added
will again extend the line to that length.


File: pspp.info,  Node: PRINT EJECT,  Next: PRINT SPACE,  Prev: PRINT,  Up: Data Input and Output

8.13 PRINT EJECT
================

     PRINT EJECT
             OUTFILE='FILE_NAME'
             RECORDS=N_LINES
             {NOTABLE,TABLE}
             /[LINE_NO] ARG...

     ARG takes one of the following forms:
             'STRING' [START-END]
             VAR_LIST START-END [TYPE_SPEC]
             VAR_LIST (FORTRAN_SPEC)
             VAR_LIST *

   'PRINT EJECT' advances to the beginning of a new output page in the
listing file or output file.  It can also output data in the same way as
'PRINT'.

   All 'PRINT EJECT' subcommands are optional.

   Without 'OUTFILE', 'PRINT EJECT' ejects the current page in the
listing file, then it produces other output, if any is specified.

   With 'OUTFILE', 'PRINT EJECT' writes its output to the specified
file.  The first line of output is written with '1' inserted in the
first column.  Commonly, this is the only line of output.  If additional
lines of output are specified, these additional lines are written with a
space inserted in the first column, as with 'PRINT'.

   *Note PRINT::, for more information on syntax and usage.


File: pspp.info,  Node: PRINT SPACE,  Next: REREAD,  Prev: PRINT EJECT,  Up: Data Input and Output

8.14 PRINT SPACE
================

     PRINT SPACE [OUTFILE='file_name'] [ENCODING='ENCODING'] [n_lines].

   'PRINT SPACE' prints one or more blank lines to an output file.

   The 'OUTFILE' subcommand is optional.  It may be used to direct
output to a file specified by file name as a string or file handle
(*note File Handles::).  If OUTFILE is not specified then output will be
directed to the listing file.

   The 'ENCODING' subcommand may only be used if 'OUTFILE' is also used.
It specifies the character encoding of the file.  *Note INSERT::, for
information on supported encodings.

   n_lines is also optional.  If present, it is an expression (*note
Expressions::) specifying the number of blank lines to be printed.  The
expression must evaluate to a nonnegative value.


File: pspp.info,  Node: REREAD,  Next: REPEATING DATA,  Prev: PRINT SPACE,  Up: Data Input and Output

8.15 REREAD
===========

     REREAD [FILE=handle] [COLUMN=column] [ENCODING='ENCODING'].

   The 'REREAD' transformation allows the previous input line in a data
file already processed by 'DATA LIST' or another input command to be
re-read for further processing.

   The 'FILE' subcommand, which is optional, is used to specify the file
to have its line re-read.  The file must be specified as the name of a
file handle (*note File Handles::).  If FILE is not specified then the
last file specified on 'DATA LIST' will be assumed (last file specified
lexically, not in terms of flow-of-control).

   By default, the line re-read is re-read in its entirety.  With the
'COLUMN' subcommand, a prefix of the line can be exempted from
re-reading.  Specify an expression (*note Expressions::) evaluating to
the first column that should be included in the re-read line.  Columns
are numbered from 1 at the left margin.

   The 'ENCODING' subcommand may only be used if the 'FILE' subcommand
is also used.  It specifies the character encoding of the file.  *Note
INSERT::, for information on supported encodings.

   Issuing 'REREAD' multiple times will not back up in the data file.
Instead, it will re-read the same line multiple times.


File: pspp.info,  Node: REPEATING DATA,  Next: WRITE,  Prev: REREAD,  Up: Data Input and Output

8.16 REPEATING DATA
===================

     REPEATING DATA
             /STARTS=START-END
             /OCCURS=N_OCCURS
             /FILE='FILE_NAME'
             /LENGTH=LENGTH
             /CONTINUED[=CONT_START-CONT_END]
             /ID=ID_START-ID_END=ID_VAR
             /{TABLE,NOTABLE}
             /DATA=VAR_SPEC...

     where each VAR_SPEC takes one of the forms
             VAR_LIST START-END [TYPE_SPEC]
             VAR_LIST (FORTRAN_SPEC)

   'REPEATING DATA' parses groups of data repeating in a uniform format,
possibly with several groups on a single line.  Each group of data
corresponds with one case.  'REPEATING DATA' may only be used within an
'INPUT PROGRAM' structure (*note INPUT PROGRAM::).  When used with 'DATA
LIST', it can be used to parse groups of cases that share a subset of
variables but differ in their other data.

   The 'STARTS' subcommand is required.  Specify a range of columns,
using literal numbers or numeric variable names.  This range specifies
the columns on the first line that are used to contain groups of data.
The ending column is optional.  If it is not specified, then the record
width of the input file is used.  For the inline file (*note BEGIN
DATA::) this is 80 columns; for a file with fixed record widths it is
the record width; for other files it is 1024 characters by default.

   The 'OCCURS' subcommand is required.  It must be a number or the name
of a numeric variable.  Its value is the number of groups present in the
current record.

   The 'DATA' subcommand is required.  It must be the last subcommand
specified.  It is used to specify the data present within each repeating
group.  Column numbers are specified relative to the beginning of a
group at column 1.  Data is specified in the same way as with 'DATA LIST
FIXED' (*note DATA LIST FIXED::).

   All other subcommands are optional.

   FILE specifies the file to read, either a file name as a string or a
file handle (*note File Handles::).  If FILE is not present then the
default is the last file handle used on 'DATA LIST' (lexically, not in
terms of flow of control).

   By default 'REPEATING DATA' will output a table describing how it
will parse the input data.  Specifying 'NOTABLE' will disable this
behavior; specifying TABLE will explicitly enable it.

   The 'LENGTH' subcommand specifies the length in characters of each
group.  If it is not present then length is inferred from the 'DATA'
subcommand.  LENGTH can be a number or a variable name.

   Normally all the data groups are expected to be present on a single
line.  Use the 'CONTINUED' command to indicate that data can be
continued onto additional lines.  If data on continuation lines starts
at the left margin and continues through the entire field width, no
column specifications are necessary on 'CONTINUED'.  Otherwise, specify
the possible range of columns in the same way as on STARTS.

   When data groups are continued from line to line, it is easy for
cases to get out of sync through careless hand editing.  The 'ID'
subcommand allows a case identifier to be present on each line of
repeating data groups.  'REPEATING DATA' will check for the same
identifier on each line and report mismatches.  Specify the range of
columns that the identifier will occupy, followed by an equals sign
('=') and the identifier variable name.  The variable must already have
been declared with 'NUMERIC' or another command.

   'REPEATING DATA' should be the last command given within an 'INPUT
PROGRAM'.  It should not be enclosed within a 'LOOP' structure (*note
LOOP::).  Use 'DATA LIST' before, not after, 'REPEATING DATA'.


File: pspp.info,  Node: WRITE,  Prev: REPEATING DATA,  Up: Data Input and Output

8.17 WRITE
==========

     WRITE
             OUTFILE='FILE_NAME'
             RECORDS=N_LINES
             {NOTABLE,TABLE}
             /[LINE_NO] ARG...

     ARG takes one of the following forms:
             'STRING' [START-END]
             VAR_LIST START-END [TYPE_SPEC]
             VAR_LIST (FORTRAN_SPEC)
             VAR_LIST *

   'WRITE' writes text or binary data to an output file.

   *Note PRINT::, for more information on syntax and usage.  'PRINT' and
'WRITE' differ in only a few ways:

   * 'WRITE' uses write formats by default, whereas 'PRINT' uses print
     formats.

   * 'PRINT' inserts a space between variables unless a format is
     explicitly specified, but 'WRITE' never inserts space between
     variables in output.

   * 'PRINT' inserts a space at the beginning of each line that it
     writes to an output file (and 'PRINT EJECT' inserts '1' at the
     beginning of each line that should begin a new page), but 'WRITE'
     does not.

   * 'PRINT' outputs the system-missing value according to its specified
     output format, whereas 'WRITE' outputs the system-missing value as
     a field filled with spaces.  Binary formats are an exception.


File: pspp.info,  Node: System and Portable File IO,  Next: Combining Data Files,  Prev: Data Input and Output,  Up: Top

9 System and Portable File I/O
******************************

The commands in this chapter read, write, and examine system files and
portable files.

* Menu:

* APPLY DICTIONARY::            Apply system file dictionary to active dataset.
* EXPORT::                      Write to a portable file.
* GET::                         Read from a system file.
* GET DATA::                    Read from foreign files.
* IMPORT::                      Read from a portable file.
* SAVE::                        Write to a system file.
* SAVE TRANSLATE::              Write data in foreign file formats.
* SYSFILE INFO::                Display system file dictionary.
* XEXPORT::                     Write to a portable file, as a transformation.
* XSAVE::                       Write to a system file, as a transformation.


File: pspp.info,  Node: APPLY DICTIONARY,  Next: EXPORT,  Up: System and Portable File IO

9.1 APPLY DICTIONARY
====================

     APPLY DICTIONARY FROM={'FILE_NAME',FILE_HANDLE}.

   'APPLY DICTIONARY' applies the variable labels, value labels, and
missing values taken from a file to corresponding variables in the
active dataset.  In some cases it also updates the weighting variable.

   Specify a system file or portable file's name, a data set name (*note
Datasets::), or a file handle name (*note File Handles::).  The
dictionary in the file will be read, but it will not replace the active
dataset's dictionary.  The file's data will not be read.

   Only variables with names that exist in both the active dataset and
the system file are considered.  Variables with the same name but
different types (numeric, string) will cause an error message.
Otherwise, the system file variables' attributes will replace those in
their matching active dataset variables:

   * If a system file variable has a variable label, then it will
     replace the variable label of the active dataset variable.  If the
     system file variable does not have a variable label, then the
     active dataset variable's variable label, if any, will be retained.

   * If the system file variable has custom attributes (*note VARIABLE
     ATTRIBUTE::), then those attributes replace the active dataset
     variable's custom attributes.  If the system file variable does not
     have custom attributes, then the active dataset variable's custom
     attributes, if any, will be retained.

   * If the active dataset variable is numeric or short string, then
     value labels and missing values, if any, will be copied to the
     active dataset variable.  If the system file variable does not have
     value labels or missing values, then those in the active dataset
     variable, if any, will not be disturbed.

   In addition to properties of variables, some properties of the active
file dictionary as a whole are updated:

   * If the system file has custom attributes (*note DATAFILE
     ATTRIBUTE::), then those attributes replace the active dataset
     variable's custom attributes.

   * If the active dataset has a weighting variable (*note WEIGHT::),
     and the system file does not, or if the weighting variable in the
     system file does not exist in the active dataset, then the active
     dataset weighting variable, if any, is retained.  Otherwise, the
     weighting variable in the system file becomes the active dataset
     weighting variable.

   'APPLY DICTIONARY' takes effect immediately.  It does not read the
active dataset.  The system file is not modified.


File: pspp.info,  Node: EXPORT,  Next: GET,  Prev: APPLY DICTIONARY,  Up: System and Portable File IO

9.2 EXPORT
==========

     EXPORT
             /OUTFILE='FILE_NAME'
             /UNSELECTED={RETAIN,DELETE}
             /DIGITS=N
             /DROP=VAR_LIST
             /KEEP=VAR_LIST
             /RENAME=(SRC_NAMES=TARGET_NAMES)...
             /TYPE={COMM,TAPE}
             /MAP

   The 'EXPORT' procedure writes the active dataset's dictionary and
data to a specified portable file.

   By default, cases excluded with FILTER are written to the file.
These can be excluded by specifying DELETE on the 'UNSELECTED'
subcommand.  Specifying RETAIN makes the default explicit.

   Portable files express real numbers in base 30.  Integers are always
expressed to the maximum precision needed to make them exact.
Non-integers are, by default, expressed to the machine's maximum natural
precision (approximately 15 decimal digits on many machines).  If many
numbers require this many digits, the portable file may significantly
increase in size.  As an alternative, the 'DIGITS' subcommand may be
used to specify the number of decimal digits of precision to write.
'DIGITS' applies only to non-integers.

   The 'OUTFILE' subcommand, which is the only required subcommand,
specifies the portable file to be written as a file name string or a
file handle (*note File Handles::).

   'DROP', 'KEEP', and 'RENAME' follow the same format as the 'SAVE'
procedure (*note SAVE::).

   The 'TYPE' subcommand specifies the character set for use in the
portable file.  Its value is currently not used.

   The 'MAP' subcommand is currently ignored.

   'EXPORT' is a procedure.  It causes the active dataset to be read.


File: pspp.info,  Node: GET,  Next: GET DATA,  Prev: EXPORT,  Up: System and Portable File IO

9.3 GET
=======

     GET
             /FILE={'FILE_NAME',FILE_HANDLE}
             /DROP=VAR_LIST
             /KEEP=VAR_LIST
             /RENAME=(SRC_NAMES=TARGET_NAMES)...
             /ENCODING='ENCODING'

   'GET' clears the current dictionary and active dataset and replaces
them with the dictionary and data from a specified file.

   The 'FILE' subcommand is the only required subcommand.  Specify the
SPSS system file, SPSS/PC+ system file, or SPSS portable file to be read
as a string file name or a file handle (*note File Handles::).

   By default, all the variables in a file are read.  The DROP
subcommand can be used to specify a list of variables that are not to be
read.  By contrast, the 'KEEP' subcommand can be used to specify
variable that are to be read, with all other variables not read.

   Normally variables in a file retain the names that they were saved
under.  Use the 'RENAME' subcommand to change these names.  Specify,
within parentheses, a list of variable names followed by an equals sign
('=') and the names that they should be renamed to.  Multiple
parenthesized groups of variable names can be included on a single
'RENAME' subcommand.  Variables' names may be swapped using a 'RENAME'
subcommand of the form '/RENAME=(A B=B A)'.

   Alternate syntax for the 'RENAME' subcommand allows the parentheses
to be eliminated.  When this is done, only a single variable may be
renamed at once.  For instance, '/RENAME=A=B'.  This alternate syntax is
deprecated.

   'DROP', 'KEEP', and 'RENAME' are executed in left-to-right order.
Each may be present any number of times.  'GET' never modifies a file on
disk.  Only the active dataset read from the file is affected by these
subcommands.

   PSPP automatically detects the encoding of string data in the file,
when possible.  The character encoding of old SPSS system files cannot
always be guessed correctly, and SPSS/PC+ system files do not include
any indication of their encoding.  Specify the 'ENCODING' subcommand
with an IANA character set name as its string argument to override the
default.  Use 'SYSFILE INFO' to analyze the encodings that might be
valid for a system file.  The 'ENCODING' subcommand is a PSPP extension.

   'GET' does not cause the data to be read, only the dictionary.  The
data is read later, when a procedure is executed.

   Use of 'GET' to read a portable file is a PSPP extension.


File: pspp.info,  Node: GET DATA,  Next: IMPORT,  Prev: GET,  Up: System and Portable File IO

9.4 GET DATA
============

     GET DATA
             /TYPE={GNM,ODS,PSQL,TXT}
             ...additional subcommands depending on TYPE...

   The 'GET DATA' command is used to read files and other data sources
created by other applications.  When this command is executed, the
current dictionary and active dataset are replaced with variables and
data read from the specified source.

   The 'TYPE' subcommand is mandatory and must be the first subcommand
specified.  It determines the type of the file or source to read.  PSPP
currently supports the following file types:

GNM
     Spreadsheet files created by Gnumeric (<http://gnumeric.org>).

ODS
     Spreadsheet files in OpenDocument format
     (<http://opendocumentformat.org>).

PSQL
     Relations from PostgreSQL databases (<http://postgresql.org>).

TXT
     Textual data files in columnar and delimited formats.

   Each supported file type has additional subcommands, explained in
separate sections below.

* Menu:

* GET DATA /TYPE=GNM/ODS::     Spreadsheets
* GET DATA /TYPE=PSQL::        Databases
* GET DATA /TYPE=TXT::         Delimited Text Files


File: pspp.info,  Node: GET DATA /TYPE=GNM/ODS,  Next: GET DATA /TYPE=PSQL,  Up: GET DATA

9.4.1 Spreadsheet Files
-----------------------

     GET DATA /TYPE={GNM, ODS}
             /FILE={'FILE_NAME'}
             /SHEET={NAME 'SHEET_NAME', INDEX N}
             /CELLRANGE={RANGE 'RANGE', FULL}
             /READNAMES={ON, OFF}
             /ASSUMEDSTRWIDTH=N.

   Gnumeric spreadsheets (<http://gnumeric.org>), and spreadsheets in
OpenDocument format
(<http://libreplanet.org/wiki/Group:OpenDocument/Software>) can be read
using the 'GET DATA' command.  Use the 'TYPE' subcommand to indicate the
file's format.  /TYPE=GNM indicates Gnumeric files, /TYPE=ODS indicates
OpenDocument.  The 'FILE' subcommand is mandatory.  Use it to specify
the name file to be read.  All other subcommands are optional.

   The format of each variable is determined by the format of the
spreadsheet cell containing the first datum for the variable.  If this
cell is of string (text) format, then the width of the variable is
determined from the length of the string it contains, unless the
'ASSUMEDSTRWIDTH' subcommand is given.

   The 'SHEET' subcommand specifies the sheet within the spreadsheet
file to read.  There are two forms of the 'SHEET' subcommand.  In the
first form, '/SHEET=name SHEET_NAME', the string SHEET_NAME is the name
of the sheet to read.  In the second form, '/SHEET=index IDX', IDX is a
integer which is the index of the sheet to read.  The first sheet has
the index 1.  If the 'SHEET' subcommand is omitted, then the command
will read the first sheet in the file.

   The 'CELLRANGE' subcommand specifies the range of cells within the
sheet to read.  If the subcommand is given as '/CELLRANGE=FULL', then
the entire sheet is read.  To read only part of a sheet, use the form
'/CELLRANGE=range 'TOP_LEFT_CELL:BOTTOM_RIGHT_CELL''.  For example, the
subcommand '/CELLRANGE=range 'C3:P19'' reads columns C-P, and rows 3-19
inclusive.  If no 'CELLRANGE' subcommand is given, then the entire sheet
is read.

   If '/READNAMES=ON' is specified, then the contents of cells of the
first row are used as the names of the variables in which to store the
data from subsequent rows.  This is the default.  If '/READNAMES=OFF' is
used, then the variables receive automatically assigned names.

   The 'ASSUMEDSTRWIDTH' subcommand specifies the maximum width of
string variables read from the file.  If omitted, the default value is
determined from the length of the string in the first spreadsheet cell
for each variable.


File: pspp.info,  Node: GET DATA /TYPE=PSQL,  Next: GET DATA /TYPE=TXT,  Prev: GET DATA /TYPE=GNM/ODS,  Up: GET DATA

9.4.2 Postgres Database Queries
-------------------------------

     GET DATA /TYPE=PSQL
              /CONNECT={CONNECTION INFO}
              /SQL={QUERY}
              [/ASSUMEDSTRWIDTH=W]
              [/UNENCRYPTED]
              [/BSIZE=N].

   The PSQL type is used to import data from a postgres database server.
The server may be located locally or remotely.  Variables are
automatically created based on the table column names or the names
specified in the SQL query.  Postgres data types of high precision, will
loose precision when imported into PSPP.  Not all the postgres data
types are able to be represented in PSPP.  If a datum cannot be
represented a warning will be issued and that datum will be set to
SYSMIS.

   The 'CONNECT' subcommand is mandatory.  It is a string specifying the
parameters of the database server from which the data should be fetched.
The format of the string is given in the postgres manual
<http://www.postgresql.org/docs/8.0/static/libpq.html#LIBPQ-CONNECT>.

   The 'SQL' subcommand is mandatory.  It must be a valid SQL string to
retrieve data from the database.

   The 'ASSUMEDSTRWIDTH' subcommand specifies the maximum width of
string variables read from the database.  If omitted, the default value
is determined from the length of the string in the first value read for
each variable.

   The 'UNENCRYPTED' subcommand allows data to be retrieved over an
insecure connection.  If the connection is not encrypted, and the
'UNENCRYPTED' subcommand is not given, then an error will occur.
Whether or not the connection is encrypted depends upon the underlying
psql library and the capabilities of the database server.

   The 'BSIZE' subcommand serves only to optimise the speed of data
transfer.  It specifies an upper limit on number of cases to fetch from
the database at once.  The default value is 4096.  If your SQL statement
fetches a large number of cases but only a small number of variables,
then the data transfer may be faster if you increase this value.
Conversely, if the number of variables is large, or if the machine on
which PSPP is running has only a small amount of memory, then a smaller
value will be better.

   The following syntax is an example:
     GET DATA /TYPE=PSQL
          /CONNECT='host=example.com port=5432 dbname=product user=fred passwd=xxxx'
          /SQL='select * from manufacturer'.


File: pspp.info,  Node: GET DATA /TYPE=TXT,  Prev: GET DATA /TYPE=PSQL,  Up: GET DATA

9.4.3 Textual Data Files
------------------------

     GET DATA /TYPE=TXT
             /FILE={'FILE_NAME',FILE_HANDLE}
             [ENCODING='ENCODING']
             [/ARRANGEMENT={DELIMITED,FIXED}]
             [/FIRSTCASE={FIRST_CASE}]
             [/IMPORTCASES=...]
             ...additional subcommands depending on ARRANGEMENT...

   When TYPE=TXT is specified, GET DATA reads data in a delimited or
fixed columnar format, much like DATA LIST (*note DATA LIST::).

   The 'FILE' subcommand is mandatory.  Specify the file to be read as a
string file name or (for textual data only) a file handle (*note File
Handles::).

   The 'ENCODING' subcommand specifies the character encoding of the
file to be read.  *Note INSERT::, for information on supported
encodings.

   The 'ARRANGEMENT' subcommand determines the file's basic format.
DELIMITED, the default setting, specifies that fields in the input data
are separated by spaces, tabs, or other user-specified delimiters.
FIXED specifies that fields in the input data appear at particular fixed
column positions within records of a case.

   By default, cases are read from the input file starting from the
first line.  To skip lines at the beginning of an input file, set
'FIRSTCASE' to the number of the first line to read: 2 to skip the first
line, 3 to skip the first two lines, and so on.

   'IMPORTCASES' is ignored, for compatibility.  Use 'N OF CASES' to
limit the number of cases read from a file (*note N OF CASES::), or
'SAMPLE' to obtain a random sample of cases (*note SAMPLE::).

   The remaining subcommands apply only to one of the two file
arrangements, described below.

* Menu:

* GET DATA /TYPE=TXT /ARRANGEMENT=DELIMITED::
* GET DATA /TYPE=TXT /ARRANGEMENT=FIXED::


File: pspp.info,  Node: GET DATA /TYPE=TXT /ARRANGEMENT=DELIMITED,  Next: GET DATA /TYPE=TXT /ARRANGEMENT=FIXED,  Up: GET DATA /TYPE=TXT

9.4.3.1 Reading Delimited Data
..............................

     GET DATA /TYPE=TXT
             /FILE={'FILE_NAME',FILE_HANDLE}
             [/ARRANGEMENT={DELIMITED,FIXED}]
             [/FIRSTCASE={FIRST_CASE}]
             [/IMPORTCASE={ALL,FIRST MAX_CASES,PERCENT PERCENT}]

             /DELIMITERS="DELIMITERS"
             [/QUALIFIER="QUOTES"
             [/DELCASE={LINE,VARIABLES N_VARIABLES}]
             /VARIABLES=DEL_VAR1 [DEL_VAR2]...
     where each DEL_VAR takes the form:
             variable format

   The GET DATA command with TYPE=TXT and ARRANGEMENT=DELIMITED reads
input data from text files in delimited format, where fields are
separated by a set of user-specified delimiters.  Its capabilities are
similar to those of DATA LIST FREE (*note DATA LIST FREE::), with a few
enhancements.

   The required 'FILE' subcommand and optional 'FIRSTCASE' and
'IMPORTCASE' subcommands are described above (*note GET DATA
/TYPE=TXT::).

   'DELIMITERS', which is required, specifies the set of characters that
may separate fields.  Each character in the string specified on
'DELIMITERS' separates one field from the next.  The end of a line also
separates fields, regardless of 'DELIMITERS'.  Two consecutive
delimiters in the input yield an empty field, as does a delimiter at the
end of a line.  A space character as a delimiter is an exception:
consecutive spaces do not yield an empty field and neither does any
number of spaces at the end of a line.

   To use a tab as a delimiter, specify '\t' at the beginning of the
'DELIMITERS' string.  To use a backslash as a delimiter, specify '\\' as
the first delimiter or, if a tab should also be a delimiter, immediately
following '\t'.  To read a data file in which each field appears on a
separate line, specify the empty string for 'DELIMITERS'.

   The optional 'QUALIFIER' subcommand names one or more characters that
can be used to quote values within fields in the input.  A field that
begins with one of the specified quote characters ends at the next
matching quote.  Intervening delimiters become part of the field,
instead of terminating it.  The ability to specify more than one quote
character is a PSPP extension.

   The character specified on 'QUALIFIER' can be embedded within a field
that it quotes by doubling the qualifier.  For example, if ''' is
specified on 'QUALIFIER', then ''a''b'' specifies a field that contains
'a'b'.

   The 'DELCASE' subcommand controls how data may be broken across lines
in the data file.  With LINE, the default setting, each line must
contain all the data for exactly one case.  For additional flexibility,
to allow a single case to be split among lines or multiple cases to be
contained on a single line, specify VARIABLES n_variables, where
n_variables is the number of variables per case.

   The 'VARIABLES' subcommand is required and must be the last
subcommand.  Specify the name of each variable and its input format
(*note Input and Output Formats::) in the order they should be read from
the input file.

Examples
........

On a Unix-like system, the '/etc/passwd' file has a format similar to
this:

     root:$1$nyeSP5gD$pDq/:0:0:,,,:/root:/bin/bash
     blp:$1$BrP/pFg4$g7OG:1000:1000:Ben Pfaff,,,:/home/blp:/bin/bash
     john:$1$JBuq/Fioq$g4A:1001:1001:John Darrington,,,:/home/john:/bin/bash
     jhs:$1$D3li4hPL$88X1:1002:1002:Jason Stover,,,:/home/jhs:/bin/csh

The following syntax reads a file in the format used by '/etc/passwd':

     GET DATA /TYPE=TXT /FILE='/etc/passwd' /DELIMITERS=':'
             /VARIABLES=username A20
                        password A40
                        uid F10
                        gid F10
                        gecos A40
                        home A40
                        shell A40.

Consider the following data on used cars:

     model   year    mileage price   type    age
     Civic   2002    29883   15900   Si      2
     Civic   2003    13415   15900   EX      1
     Civic   1992    107000  3800    n/a     12
     Accord  2002    26613   17900   EX      1

The following syntax can be used to read the used car data:

     GET DATA /TYPE=TXT /FILE='cars.data' /DELIMITERS=' ' /FIRSTCASE=2
             /VARIABLES=model A8
                        year F4
                        mileage F6
                        price F5
                        type A4
                        age F2.

Consider the following information on animals in a pet store:

     'Pet''s Name', "Age", "Color", "Date Received", "Price", "Height", "Type"
     , (Years), , , (Dollars), ,
     "Rover", 4.5, Brown, "12 Feb 2004", 80, '1''4"', "Dog"
     "Charlie", , Gold, "5 Apr 2007", 12.3, "3""", "Fish"
     "Molly", 2, Black, "12 Dec 2006", 25, '5"', "Cat"
     "Gilly", , White, "10 Apr 2007", 10, "3""", "Guinea Pig"

The following syntax can be used to read the pet store data:

     GET DATA /TYPE=TXT /FILE='pets.data' /DELIMITERS=', ' /QUALIFIER='''"' /ESCAPE
             /FIRSTCASE=3
             /VARIABLES=name A10
                        age F3.1
                        color A5
                        received EDATE10
                        price F5.2
                        height a5
                        type a10.


File: pspp.info,  Node: GET DATA /TYPE=TXT /ARRANGEMENT=FIXED,  Prev: GET DATA /TYPE=TXT /ARRANGEMENT=DELIMITED,  Up: GET DATA /TYPE=TXT

9.4.3.2 Reading Fixed Columnar Data
...................................

     GET DATA /TYPE=TXT
             /FILE={'file_name',FILE_HANDLE}
             [/ARRANGEMENT={DELIMITED,FIXED}]
             [/FIRSTCASE={FIRST_CASE}]
             [/IMPORTCASE={ALL,FIRST MAX_CASES,PERCENT PERCENT}]

             [/FIXCASE=N]
             /VARIABLES FIXED_VAR [FIXED_VAR]...
                 [/rec# FIXED_VAR [FIXED_VAR]...]...
     where each FIXED_VAR takes the form:
             VARIABLE START-END FORMAT

   The 'GET DATA' command with TYPE=TXT and ARRANGEMENT=FIXED reads
input data from text files in fixed format, where each field is located
in particular fixed column positions within records of a case.  Its
capabilities are similar to those of DATA LIST FIXED (*note DATA LIST
FIXED::), with a few enhancements.

   The required 'FILE' subcommand and optional 'FIRSTCASE' and
'IMPORTCASE' subcommands are described above (*note GET DATA
/TYPE=TXT::).

   The optional 'FIXCASE' subcommand may be used to specify the positive
integer number of input lines that make up each case.  The default value
is 1.

   The 'VARIABLES' subcommand, which is required, specifies the
positions at which each variable can be found.  For each variable,
specify its name, followed by its start and end column separated by '-'
(e.g. '0-9'), followed by an input format type (e.g. 'F') or a full
format specification (e.g. 'DOLLAR12.2').  For this command, columns are
numbered starting from 0 at the left column.  Introduce the variables in
the second and later lines of a case by a slash followed by the number
of the line within the case, e.g. '/2' for the second line.

Examples
........

Consider the following data on used cars:

     model   year    mileage price   type    age
     Civic   2002    29883   15900   Si      2
     Civic   2003    13415   15900   EX      1
     Civic   1992    107000  3800    n/a     12
     Accord  2002    26613   17900   EX      1

The following syntax can be used to read the used car data:

     GET DATA /TYPE=TXT /FILE='cars.data' /ARRANGEMENT=FIXED /FIRSTCASE=2
             /VARIABLES=model 0-7 A
                        year 8-15 F
                        mileage 16-23 F
                        price 24-31 F
                        type 32-40 A
                        age 40-47 F.


File: pspp.info,  Node: IMPORT,  Next: SAVE,  Prev: GET DATA,  Up: System and Portable File IO

9.5 IMPORT
==========

     IMPORT
             /FILE='FILE_NAME'
             /TYPE={COMM,TAPE}
             /DROP=VAR_LIST
             /KEEP=VAR_LIST
             /RENAME=(SRC_NAMES=TARGET_NAMES)...

   The 'IMPORT' transformation clears the active dataset dictionary and
data and replaces them with a dictionary and data from a system file or
portable file.

   The 'FILE' subcommand, which is the only required subcommand,
specifies the portable file to be read as a file name string or a file
handle (*note File Handles::).

   The 'TYPE' subcommand is currently not used.

   'DROP', 'KEEP', and 'RENAME' follow the syntax used by 'GET' (*note
GET::).

   'IMPORT' does not cause the data to be read; only the dictionary.
The data is read later, when a procedure is executed.

   Use of 'IMPORT' to read a system file is a PSPP extension.


File: pspp.info,  Node: SAVE,  Next: SAVE TRANSLATE,  Prev: IMPORT,  Up: System and Portable File IO

9.6 SAVE
========

     SAVE
             /OUTFILE={'FILE_NAME',FILE_HANDLE}
             /UNSELECTED={RETAIN,DELETE}
             /{UNCOMPRESSED,COMPRESSED,ZCOMPRESSED}
             /PERMISSIONS={WRITEABLE,READONLY}
             /DROP=VAR_LIST
             /KEEP=VAR_LIST
             /VERSION=VERSION
             /RENAME=(SRC_NAMES=TARGET_NAMES)...
             /NAMES
             /MAP

   The 'SAVE' procedure causes the dictionary and data in the active
dataset to be written to a system file.

   OUTFILE is the only required subcommand.  Specify the system file to
be written as a string file name or a file handle (*note File
Handles::).

   By default, cases excluded with FILTER are written to the system
file.  These can be excluded by specifying 'DELETE' on the 'UNSELECTED'
subcommand.  Specifying 'RETAIN' makes the default explicit.

   The 'UNCOMPRESSED', 'COMPRESSED', and 'ZCOMPRESSED' subcommand
determine the system file's compression level:

'UNCOMPRESSED'
     Data is not compressed.  Each numeric value uses 8 bytes of disk
     space.  Each string value uses one byte per column width, rounded
     up to a multiple of 8 bytes.

'COMPRESSED'
     Data is compressed with a simple algorithm.  Each integer numeric
     value between -99 and 151, inclusive, or system missing value uses
     one byte of disk space.  Each 8-byte segment of a string that
     consists only of spaces uses 1 byte.  Any other numeric value or
     8-byte string segment uses 9 bytes of disk space.

'ZCOMPRESSED'
     Data is compressed with the "deflate" compression algorithm
     specified in RFC 1951 (the same algorithm used by 'gzip').  Files
     written with this compression level cannot be read by PSPP 0.8.1 or
     earlier or by SPSS 20 or earlier.

   'COMPRESSED' is the default compression level.  The SET command
(*note SET::) can change this default.

   The 'PERMISSIONS' subcommand specifies permissions for the new system
file.  WRITEABLE, the default, creates the file with read and write
permission.  READONLY creates the file for read-only access.

   By default, all the variables in the active dataset dictionary are
written to the system file.  The 'DROP' subcommand can be used to
specify a list of variables not to be written.  In contrast, KEEP
specifies variables to be written, with all variables not specified not
written.

   Normally variables are saved to a system file under the same names
they have in the active dataset.  Use the 'RENAME' subcommand to change
these names.  Specify, within parentheses, a list of variable names
followed by an equals sign ('=') and the names that they should be
renamed to.  Multiple parenthesized groups of variable names can be
included on a single 'RENAME' subcommand.  Variables' names may be
swapped using a 'RENAME' subcommand of the form '/RENAME=(A B=B A)'.

   Alternate syntax for the 'RENAME' subcommand allows the parentheses
to be eliminated.  When this is done, only a single variable may be
renamed at once.  For instance, '/RENAME=A=B'.  This alternate syntax is
deprecated.

   'DROP', 'KEEP', and 'RENAME' are performed in left-to-right order.
They each may be present any number of times.  'SAVE' never modifies the
active dataset.  'DROP', 'KEEP', and 'RENAME' only affect the system
file written to disk.

   The 'VERSION' subcommand specifies the version of the file format.
Valid versions are 2 and 3.  The default version is 3.  In version 2
system files, variable names longer than 8 bytes will be truncated.  The
two versions are otherwise identical.

   The 'NAMES' and 'MAP' subcommands are currently ignored.

   'SAVE' causes the data to be read.  It is a procedure.


File: pspp.info,  Node: SAVE TRANSLATE,  Next: SYSFILE INFO,  Prev: SAVE,  Up: System and Portable File IO

9.7 SAVE TRANSLATE
==================

     SAVE TRANSLATE
             /OUTFILE={'FILE_NAME',FILE_HANDLE}
             /TYPE={CSV,TAB}
             [/REPLACE]
             [/MISSING={IGNORE,RECODE}]

             [/DROP=VAR_LIST]
             [/KEEP=VAR_LIST]
             [/RENAME=(SRC_NAMES=TARGET_NAMES)...]
             [/UNSELECTED={RETAIN,DELETE}]
             [/MAP]

             ...additional subcommands depending on TYPE...

   The 'SAVE TRANSLATE' command is used to save data into various
formats understood by other applications.

   The 'OUTFILE' and 'TYPE' subcommands are mandatory.  'OUTFILE'
specifies the file to be written, as a string file name or a file handle
(*note File Handles::).  'TYPE' determines the type of the file or
source to read.  It must be one of the following:

CSV
     Comma-separated value format,

TAB
     Tab-delimited format.

   By default, 'SAVE TRANSLATE' will not overwrite an existing file.
Use 'REPLACE' to force an existing file to be overwritten.

   With MISSING=IGNORE, the default, 'SAVE TRANSLATE' treats
user-missing values as if they were not missing.  Specify MISSING=RECODE
to output numeric user-missing values like system-missing values and
string user-missing values as all spaces.

   By default, all the variables in the active dataset dictionary are
saved to the system file, but 'DROP' or 'KEEP' can select a subset of
variable to save.  The 'RENAME' subcommand can also be used to change
the names under which variables are saved.  'UNSELECTED' determines
whether cases filtered out by the 'FILTER' command are written to the
output file.  These subcommands have the same syntax and meaning as on
the 'SAVE' command (*note SAVE::).

   Each supported file type has additional subcommands, explained in
separate sections below.

   'SAVE TRANSLATE' causes the data to be read.  It is a procedure.

* Menu:

* SAVE TRANSLATE /TYPE=CSV and TYPE=TAB::


File: pspp.info,  Node: SAVE TRANSLATE /TYPE=CSV and TYPE=TAB,  Up: SAVE TRANSLATE

9.7.1 Writing Comma- and Tab-Separated Data Files
-------------------------------------------------

     SAVE TRANSLATE
             /OUTFILE={'FILE_NAME',FILE_HANDLE}
             /TYPE=CSV
             [/REPLACE]
             [/MISSING={IGNORE,RECODE}]

             [/DROP=VAR_LIST]
             [/KEEP=VAR_LIST]
             [/RENAME=(SRC_NAMES=TARGET_NAMES)...]
             [/UNSELECTED={RETAIN,DELETE}]

             [/FIELDNAMES]
             [/CELLS={VALUES,LABELS}]
             [/TEXTOPTIONS DELIMITER='DELIMITER']
             [/TEXTOPTIONS QUALIFIER='QUALIFIER']
             [/TEXTOPTIONS DECIMAL={DOT,COMMA}]
             [/TEXTOPTIONS FORMAT={PLAIN,VARIABLE}]

   The SAVE TRANSLATE command with TYPE=CSV or TYPE=TAB writes data in a
comma- or tab-separated value format similar to that described by
RFC 4180.  Each variable becomes one output column, and each case
becomes one line of output.  If FIELDNAMES is specified, an additional
line at the top of the output file lists variable names.

   The CELLS and TEXTOPTIONS FORMAT settings determine how values are
written to the output file:

CELLS=VALUES FORMAT=PLAIN (the default settings)
     Writes variables to the output in "plain" formats that ignore the
     details of variable formats.  Numeric values are written as plain
     decimal numbers with enough digits to indicate their exact values
     in machine representation.  Numeric values include 'e' followed by
     an exponent if the exponent value would be less than -4 or greater
     than 16.  Dates are written in MM/DD/YYYY format and times in
     HH:MM:SS format.  WKDAY and MONTH values are written as decimal
     numbers.

     Numeric values use, by default, the decimal point character set
     with SET DECIMAL (*note SET DECIMAL::).  Use DECIMAL=DOT or
     DECIMAL=COMMA to force a particular decimal point character.

CELLS=VALUES FORMAT=VARIABLE
     Writes variables using their print formats.  Leading and trailing
     spaces are removed from numeric values, and trailing spaces are
     removed from string values.

CELLS=LABEL FORMAT=PLAIN
CELLS=LABEL FORMAT=VARIABLE
     Writes value labels where they exist, and otherwise writes the
     values themselves as described above.

   Regardless of CELLS and TEXTOPTIONS FORMAT, numeric system-missing
values are output as a single space.

   For TYPE=TAB, tab characters delimit values.  For TYPE=CSV, the
TEXTOPTIONS DELIMITER and DECIMAL settings determine the character that
separate values within a line.  If DELIMITER is specified, then the
specified string separate values.  If DELIMITER is not specified, then
the default is a comma with DECIMAL=DOT or a semicolon with
DECIMAL=COMMA. If DECIMAL is not given either, it is implied by the
decimal point character set with SET DECIMAL (*note SET DECIMAL::).

   The TEXTOPTIONS QUALIFIER setting specifies a character that is
output before and after a value that contains the delimiter character or
the qualifier character.  The default is a double quote ('"').  A
qualifier character that appears within a value is doubled.


File: pspp.info,  Node: SYSFILE INFO,  Next: XEXPORT,  Prev: SAVE TRANSLATE,  Up: System and Portable File IO

9.8 SYSFILE INFO
================

     SYSFILE INFO FILE='FILE_NAME' [ENCODING='ENCODING'].

   'SYSFILE INFO' reads the dictionary in an SPSS system file, SPSS/PC+
system file, or SPSS portable file, and displays the information in its
dictionary.

   Specify a file name or file handle.  'SYSFILE INFO' reads that file
and displays information on its dictionary.

   PSPP automatically detects the encoding of string data in the file,
when possible.  The character encoding of old SPSS system files cannot
always be guessed correctly, and SPSS/PC+ system files do not include
any indication of their encoding.  Specify the 'ENCODING' subcommand
with an IANA character set name as its string argument to override the
default, or specify 'ENCODING='DETECT'' to analyze and report possibly
valid encodings for the system file.  The 'ENCODING' subcommand is a
PSPP extension.

   'SYSFILE INFO' does not affect the current active dataset.


File: pspp.info,  Node: XEXPORT,  Next: XSAVE,  Prev: SYSFILE INFO,  Up: System and Portable File IO

9.9 XEXPORT
===========

     XEXPORT
             /OUTFILE='FILE_NAME'
             /DIGITS=N
             /DROP=VAR_LIST
             /KEEP=VAR_LIST
             /RENAME=(SRC_NAMES=TARGET_NAMES)...
             /TYPE={COMM,TAPE}
             /MAP

   The 'EXPORT' transformation writes the active dataset dictionary and
data to a specified portable file.

   This transformation is a PSPP extension.

   It is similar to the 'EXPORT' procedure, with two differences:

   * 'XEXPORT' is a transformation, not a procedure.  It is executed
     when the data is read by a procedure or procedure-like command.

   * 'XEXPORT' does not support the 'UNSELECTED' subcommand.

   *Note EXPORT::, for more information.


File: pspp.info,  Node: XSAVE,  Prev: XEXPORT,  Up: System and Portable File IO

9.10 XSAVE
==========

     XSAVE
             /OUTFILE='FILE_NAME'
             /{UNCOMPRESSED,COMPRESSED,ZCOMPRESSED}
             /PERMISSIONS={WRITEABLE,READONLY}
             /DROP=VAR_LIST
             /KEEP=VAR_LIST
             /VERSION=VERSION
             /RENAME=(SRC_NAMES=TARGET_NAMES)...
             /NAMES
             /MAP

   The 'XSAVE' transformation writes the active dataset's dictionary and
data to a system file.  It is similar to the 'SAVE' procedure, with two
differences:

   * 'XSAVE' is a transformation, not a procedure.  It is executed when
     the data is read by a procedure or procedure-like command.

   * 'XSAVE' does not support the 'UNSELECTED' subcommand.

   *Note SAVE::, for more information.


File: pspp.info,  Node: Combining Data Files,  Next: Variable Attributes,  Prev: System and Portable File IO,  Up: Top

10 Combining Data Files
***********************

This chapter describes commands that allow data from system files,
portable files, and open datasets to be combined to form a new active
dataset.  These commands can combine data files in the following ways:

   * 'ADD FILES' interleaves or appends the cases from each input file.
     It is used with input files that have variables in common, but
     distinct sets of cases.

   * 'MATCH FILES' adds the data together in cases that match across
     multiple input files.  It is used with input files that have cases
     in common, but different information about each case.

   * 'UPDATE' updates a master data file from data in a set of
     transaction files.  Each case in a transaction data file modifies a
     matching case in the primary data file, or it adds a new case if no
     matching case can be found.

   These commands share the majority of their syntax, which is described
in the following section, followed by one section for each command that
describes its specific syntax and semantics.

* Menu:

* Combining Files Common Syntax::
* ADD FILES::                   Interleave cases from multiple files.
* MATCH FILES::                 Merge cases from multiple files.
* UPDATE::                      Update cases using transactional data.


File: pspp.info,  Node: Combining Files Common Syntax,  Next: ADD FILES,  Up: Combining Data Files

10.1 Common Syntax
==================

     Per input file:
             /FILE={*,'FILE_NAME'}
             [/RENAME=(SRC_NAMES=TARGET_NAMES)...]
             [/IN=VAR_NAME]
             [/SORT]

     Once per command:
             /BY VAR_LIST[({D|A})] [VAR_LIST[({D|A}]]...
             [/DROP=VAR_LIST]
             [/KEEP=VAR_LIST]
             [/FIRST=VAR_NAME]
             [/LAST=VAR_NAME]
             [/MAP]

   This section describes the syntactical features in common among the
'ADD FILES', 'MATCH FILES', and 'UPDATE' commands.  The following
sections describe details specific to each command.

   Each of these commands reads two or more input files and combines
them.  The command's output becomes the new active dataset.  None of the
commands actually change the input files.  Therefore, if you want the
changes to become permanent, you must explicitly save them using an
appropriate procedure or transformation (*note System and Portable File
IO::).

   The syntax of each command begins with a specification of the files
to be read as input.  For each input file, specify FILE with a system
file or portable file's name as a string, a dataset (*note Datasets::)
or file handle name, (*note File Handles::), or an asterisk ('*') to use
the active dataset as input.  Use of portable files on 'FILE' is a PSPP
extension.

   At least two 'FILE' subcommands must be specified.  If the active
dataset is used as an input source, then 'TEMPORARY' must not be in
effect.

   Each 'FILE' subcommand may be followed by any number of 'RENAME'
subcommands that specify a parenthesized group or groups of variable
names as they appear in the input file, followed by those variables' new
names, separated by an equals sign ('='), e.g.
'/RENAME=(OLD1=NEW1)(OLD2=NEW2)'.  To rename a single variable, the
parentheses may be omitted: '/RENAME=OLD=NEW'.  Within a parenthesized
group, variables are renamed simultaneously, so that '/RENAME=(A B=B A)'
exchanges the names of variables A and B.  Otherwise, renaming occurs in
left-to-right order.

   Each 'FILE' subcommand may optionally be followed by a single 'IN'
subcommand, which creates a numeric variable with the specified name and
format F1.0.  The IN variable takes value 1 in an output case if the
given input file contributed to that output case, and 0 otherwise.  The
'DROP', 'KEEP', and 'RENAME' subcommands have no effect on IN variables.

   If 'BY' is used (see below), the 'SORT' keyword must be specified
after a 'FILE' if that input file is not already sorted on the 'BY'
variables.  When 'SORT' is specified, PSPP sorts the input file's data
on the 'BY' variables before it applies it to the command.  When 'SORT'
is used, 'BY' is required.  'SORT' is a PSPP extension.

   PSPP merges the dictionaries of all of the input files to form the
dictionary of the new active dataset, like so:

   * The variables in the new active dataset are the union of all the
     input files' variables, matched based on their name.  When a single
     input file contains a variable with a given name, the output file
     will contain exactly that variable.  When more than one input file
     contains a variable with a given name, those variables must all
     have the same type (numeric or string) and, for string variables,
     the same width.  Variables are matched after renaming with the
     'RENAME' subcommand.  Thus, 'RENAME' can be used to resolve
     conflicts.

   * The variable label for each output variable is taken from the first
     specified input file that has a variable label for that variable,
     and similarly for value labels and missing values.

   * The file label of the new active dataset (*note FILE LABEL::) is
     that of the first specified 'FILE' that has a file label.

   * The documents in the new active dataset (*note DOCUMENT::) are the
     concatenation of all the input files' documents, in the order in
     which the 'FILE' subcommands are specified.

   * If all of the input files are weighted on the same variable, then
     the new active dataset is weighted on that variable.  Otherwise,
     the new active dataset is not weighted.

   The remaining subcommands apply to the output file as a whole, rather
than to individual input files.  They must be specified at the end of
the command specification, following all of the 'FILE' and related
subcommands.  The most important of these subcommands is 'BY', which
specifies a set of one or more variables that may be used to find
corresponding cases in each of the input files.  The variables specified
on 'BY' must be present in all of the input files.  Furthermore, if any
of the input files are not sorted on the 'BY' variables, then 'SORT'
must be specified for those input files.

   The variables listed on 'BY' may include (A) or (D) annotations to
specify ascending or descending sort order.  *Note SORT CASES::, for
more details on this notation.  Adding (A) or (D) to the 'BY' subcommand
specification is a PSPP extension.

   The 'DROP' subcommand can be used to specify a list of variables to
exclude from the output.  By contrast, the 'KEEP' subcommand can be used
to specify variables to include in the output; all variables not listed
are dropped.  'DROP' and 'KEEP' are executed in left-to-right order and
may be repeated any number of times.  'DROP' and 'KEEP' do not affect
variables created by the 'IN', 'FIRST', and 'LAST' subcommands, which
are always included in the new active dataset, but they can be used to
drop 'BY' variables.

   The 'FIRST' and 'LAST' subcommands are optional.  They may only be
specified on 'MATCH FILES' and 'ADD FILES', and only when 'BY' is used.
'FIRST' and 'LIST' each adds a numeric variable to the new active
dataset, with the name given as the subcommand's argument and F1.0 print
and write formats.  The value of the 'FIRST' variable is 1 in the first
output case with a given set of values for the 'BY' variables, and 0 in
other cases.  Similarly, the 'LAST' variable is 1 in the last case with
a given of 'BY' values, and 0 in other cases.

   When any of these commands creates an output case, variables that are
only in files that are not present for the current case are set to the
system-missing value for numeric variables or spaces for string
variables.

   These commands may combine any number of files, limited only by the
machine's memory.


File: pspp.info,  Node: ADD FILES,  Next: MATCH FILES,  Prev: Combining Files Common Syntax,  Up: Combining Data Files

10.2 ADD FILES
==============

     ADD FILES

     Per input file:
             /FILE={*,'FILE_NAME'}
             [/RENAME=(SRC_NAMES=TARGET_NAMES)...]
             [/IN=VAR_NAME]
             [/SORT]

     Once per command:
             [/BY VAR_LIST[({D|A})] [VAR_LIST[({D|A})]...]]
             [/DROP=VAR_LIST]
             [/KEEP=VAR_LIST]
             [/FIRST=VAR_NAME]
             [/LAST=VAR_NAME]
             [/MAP]

   'ADD FILES' adds cases from multiple input files.  The output, which
replaces the active dataset, consists all of the cases in all of the
input files.

   'ADD FILES' shares the bulk of its syntax with other PSPP commands
for combining multiple data files.  *Note Combining Files Common
Syntax::, above, for an explanation of this common syntax.

   When 'BY' is not used, the output of 'ADD FILES' consists of all the
cases from the first input file specified, followed by all the cases
from the second file specified, and so on.  When 'BY' is used, the
output is additionally sorted on the 'BY' variables.

   When 'ADD FILES' creates an output case, variables that are not part
of the input file from which the case was drawn are set to the
system-missing value for numeric variables or spaces for string
variables.


File: pspp.info,  Node: MATCH FILES,  Next: UPDATE,  Prev: ADD FILES,  Up: Combining Data Files

10.3 MATCH FILES
================

     MATCH FILES

     Per input file:
             /{FILE,TABLE}={*,'FILE_NAME'}
             [/RENAME=(SRC_NAMES=TARGET_NAMES)...]
             [/IN=VAR_NAME]
             [/SORT]

     Once per command:
             /BY VAR_LIST[({D|A}] [VAR_LIST[({D|A})]...]
             [/DROP=VAR_LIST]
             [/KEEP=VAR_LIST]
             [/FIRST=VAR_NAME]
             [/LAST=VAR_NAME]
             [/MAP]

   'MATCH FILES' merges sets of corresponding cases in multiple input
files into single cases in the output, combining their data.

   'MATCH FILES' shares the bulk of its syntax with other PSPP commands
for combining multiple data files.  *Note Combining Files Common
Syntax::, above, for an explanation of this common syntax.

   How 'MATCH FILES' matches up cases from the input files depends on
whether 'BY' is specified:

   * If 'BY' is not used, 'MATCH FILES' combines the first case from
     each input file to produce the first output case, then the second
     case from each input file for the second output case, and so on.
     If some input files have fewer cases than others, then the shorter
     files do not contribute to cases output after their input has been
     exhausted.

   * If 'BY' is used, 'MATCH FILES' combines cases from each input file
     that have identical values for the 'BY' variables.

     When 'BY' is used, 'TABLE' subcommands may be used to introduce
     "table lookup file".  'TABLE' has same syntax as 'FILE', and the
     'RENAME', 'IN', and 'SORT' subcommands may follow a 'TABLE' in the
     same way as 'FILE'.  Regardless of the number of 'TABLE's, at least
     one 'FILE' must specified.  Table lookup files are treated in the
     same way as other input files for most purposes and, in particular,
     table lookup files must be sorted on the 'BY' variables or the
     'SORT' subcommand must be specified for that 'TABLE'.

     Cases in table lookup files are not consumed after they have been
     used once.  This means that data in table lookup files can
     correspond to any number of cases in 'FILE' input files.  Table
     lookup files are analogous to lookup tables in traditional
     relational database systems.

     If a table lookup file contains more than one case with a given set
     of 'BY' variables, only the first case is used.

   When 'MATCH FILES' creates an output case, variables that are only in
files that are not present for the current case are set to the
system-missing value for numeric variables or spaces for string
variables.


File: pspp.info,  Node: UPDATE,  Prev: MATCH FILES,  Up: Combining Data Files

10.4 UPDATE
===========

     UPDATE

     Per input file:
             /FILE={*,'FILE_NAME'}
             [/RENAME=(SRC_NAMES=TARGET_NAMES)...]
             [/IN=VAR_NAME]
             [/SORT]

     Once per command:
             /BY VAR_LIST[({D|A})] [VAR_LIST[({D|A})]]...
             [/DROP=VAR_LIST]
             [/KEEP=VAR_LIST]
             [/MAP]

   'UPDATE' updates a "master file" by applying modifications from one
or more "transaction files".

   'UPDATE' shares the bulk of its syntax with other PSPP commands for
combining multiple data files.  *Note Combining Files Common Syntax::,
above, for an explanation of this common syntax.

   At least two 'FILE' subcommands must be specified.  The first 'FILE'
subcommand names the master file, and the rest name transaction files.
Every input file must either be sorted on the variables named on the
'BY' subcommand, or the 'SORT' subcommand must be used just after the
'FILE' subcommand for that input file.

   'UPDATE' uses the variables specified on the 'BY' subcommand, which
is required, to attempt to match each case in a transaction file with a
case in the master file:

   * When a match is found, then the values of the variables present in
     the transaction file replace those variables' values in the new
     active file.  If there are matching cases in more than more
     transaction file, PSPP applies the replacements from the first
     transaction file, then from the second transaction file, and so on.
     Similarly, if a single transaction file has cases with duplicate
     'BY' values, then those are applied in order to the master file.

     When a variable in a transaction file has a missing value or when a
     string variable's value is all blanks, that value is never used to
     update the master file.

   * If a case in the master file has no matching case in any
     transaction file, then it is copied unchanged to the output.

   * If a case in a transaction file has no matching case in the master
     file, then it causes a new case to be added to the output,
     initialized from the values in the transaction file.


File: pspp.info,  Node: Variable Attributes,  Next: Data Manipulation,  Prev: Combining Data Files,  Up: Top

11 Manipulating variables
*************************

The variables in the active dataset dictionary are important.  There are
several utility functions for examining and adjusting them.

* Menu:

* ADD VALUE LABELS::            Add value labels to variables.
* DELETE VARIABLES::            Delete variables.
* DISPLAY::                     Display information about the active dataset.
* FORMATS::                     Set print and write formats.
* LEAVE::                       Don't clear variables between cases.
* MISSING VALUES::              Set missing values for variables.
* MODIFY VARS::                 Rename, reorder, and drop variables.
* MRSETS::                      Add, modify, and list multiple response sets.
* NUMERIC::                     Create new numeric variables.
* PRINT FORMATS::               Set variable print formats.
* RENAME VARIABLES::            Rename variables.
* SORT VARIABLES::              Reorder variables.
* VALUE LABELS::                Set value labels for variables.
* STRING::                      Create new string variables.
* VARIABLE ATTRIBUTE::          Set custom attributes on variables.
* VARIABLE LABELS::             Set variable labels for variables.
* VARIABLE ALIGNMENT::          Set the alignment for display.
* VARIABLE WIDTH::              Set the display width.
* VARIABLE LEVEL::              Set the measurement level.
* VARIABLE ROLE::               Set the role that a variable fills in analysis.
* VECTOR::                      Declare an array of variables.
* WRITE FORMATS::               Set variable write formats.


File: pspp.info,  Node: ADD VALUE LABELS,  Next: DELETE VARIABLES,  Up: Variable Attributes

11.1 ADD VALUE LABELS
=====================

     ADD VALUE LABELS
             /VAR_LIST VALUE 'LABEL' [VALUE 'LABEL']...

   'ADD VALUE LABELS' has the same syntax and purpose as 'VALUE LABELS'
(*note VALUE LABELS::), but it does not clear value labels from the
variables before adding the ones specified.


File: pspp.info,  Node: DELETE VARIABLES,  Next: DISPLAY,  Prev: ADD VALUE LABELS,  Up: Variable Attributes

11.2 DELETE VARIABLES
=====================

     DELETE VARIABLES VAR_LIST.

   'DELETE VARIABLES' deletes the specified variables from the
dictionary.  It may not be used to delete all variables from the
dictionary; use 'NEW FILE' to do that (*note NEW FILE::).

   'DELETE VARIABLES' should not be used after defining transformations
but before executing a procedure.  If it is used in such a context, it
causes the data to be read.  If it is used while 'TEMPORARY' is in
effect, it causes the temporary transformations to become permanent.


File: pspp.info,  Node: DISPLAY,  Next: FORMATS,  Prev: DELETE VARIABLES,  Up: Variable Attributes

11.3 DISPLAY
============

     DISPLAY [SORTED] NAMES [[/VARIABLES=]VAR_LIST].
     DISPLAY [SORTED] INDEX [[/VARIABLES=]VAR_LIST].
     DISPLAY [SORTED] LABELS [[/VARIABLES=]VAR_LIST].
     DISPLAY [SORTED] VARIABLES [[/VARIABLES=]VAR_LIST].
     DISPLAY [SORTED] DICTIONARY [[/VARIABLES=]VAR_LIST].
     DISPLAY [SORTED] SCRATCH [[/VARIABLES=]VAR_LIST].
     DISPLAY [SORTED] ATTRIBUTES [[/VARIABLES=]VAR_LIST].
     DISPLAY [SORTED] @ATTRIBUTES [[/VARIABLES=]VAR_LIST].
     DISPLAY [SORTED] VECTORS.

   'DISPLAY' displays information about the active dataset.  A variety
of different forms of information can be requested.

   The following keywords primarily cause information about variables to
be displayed.  With these keywords, by default information is displayed
about all variable in the active dataset, in the order that variables
occur in the active dataset dictionary.  The 'SORTED' keyword causes
output to be sorted alphabetically by variable name.  The 'VARIABLES'
subcommand limits output to the specified variables.

NAMES
     The variables' names are displayed.

INDEX
     The variables' names are displayed along with a value describing
     their position within the active dataset dictionary.

LABELS
     Variable names, positions, and variable labels are displayed.

VARIABLES
     Variable names, positions, print and write formats, and missing
     values are displayed.

DICTIONARY
     Variable names, positions, print and write formats, missing values,
     variable labels, and value labels are displayed.

SCRATCH
     Variable names are displayed, for scratch variables only (*note
     Scratch Variables::).

ATTRIBUTES
@ATTRIBUTES
     Datafile and variable attributes are displayed.  The first form of
     the command omits those attributes whose names begin with '@' or
     '$@'.  In the second for, all datafile and variable attributes are
     displayed.

   With the 'VECTOR' keyword, 'DISPLAY' lists all the currently declared
vectors.  If the 'SORTED' keyword is given, the vectors are listed in
alphabetical order; otherwise, they are listed in textual order of
definition within the PSPP syntax file.

   For related commands, see *note DISPLAY DOCUMENTS:: and *note DISPLAY
FILE LABEL::.


File: pspp.info,  Node: FORMATS,  Next: LEAVE,  Prev: DISPLAY,  Up: Variable Attributes

11.4 FORMATS
============

     FORMATS VAR_LIST (FMT_SPEC) [VAR_LIST (FMT_SPEC)]....

   'FORMATS' set both print and write formats for the specified
variables to the specified format specification.  *Note Input and Output
Formats::.

   Specify a list of variables followed by a format specification in
parentheses.  The print and write formats of the specified variables
will be changed.  All of the variables listed together must have the
same type and, for string variables, the same width.

   Additional lists of variables and formats may be included following
the first one.

   'FORMATS' takes effect immediately.  It is not affected by
conditional and looping structures such as 'DO IF' or 'LOOP'.


File: pspp.info,  Node: LEAVE,  Next: MISSING VALUES,  Prev: FORMATS,  Up: Variable Attributes

11.5 LEAVE
==========

     LEAVE VAR_LIST.

   'LEAVE' prevents the specified variables from being reinitialized
whenever a new case is processed.

   Normally, when a data file is processed, every variable in the active
dataset is initialized to the system-missing value or spaces at the
beginning of processing for each case.  When a variable has been
specified on 'LEAVE', this is not the case.  Instead, that variable is
initialized to 0 (not system-missing) or spaces for the first case.
After that, it retains its value between cases.

   This becomes useful for counters.  For instance, in the example below
the variable 'SUM' maintains a running total of the values in the 'ITEM'
variable.

     DATA LIST /ITEM 1-3.
     COMPUTE SUM=SUM+ITEM.
     PRINT /ITEM SUM.
     LEAVE SUM
     BEGIN DATA.
     123
     404
     555
     999
     END DATA.

Partial output from this example:

     123   123.00
     404   527.00
     555  1082.00
     999  2081.00

   It is best to use 'LEAVE' command immediately before invoking a
procedure command, because the left status of variables is reset by
certain transformations--for instance, 'COMPUTE' and 'IF'.  Left status
is also reset by all procedure invocations.


File: pspp.info,  Node: MISSING VALUES,  Next: MODIFY VARS,  Prev: LEAVE,  Up: Variable Attributes

11.6 MISSING VALUES
===================

     MISSING VALUES VAR_LIST (MISSING_VALUES).

     where MISSING_VALUES takes one of the following forms:
             NUM1
             NUM1, NUM2
             NUM1, NUM2, NUM3
             NUM1 THRU NUM2
             NUM1 THRU NUM2, NUM3
             STRING1
             STRING1, STRING2
             STRING1, STRING2, STRING3
     As part of a range, 'LO' or 'LOWEST' may take the place of NUM1;
     'HI' or 'HIGHEST' may take the place of NUM2.

   'MISSING VALUES' sets user-missing values for numeric and string
variables.  Long string variables may have missing values, but
characters after the first 8 bytes of the missing value must be spaces.

   Specify a list of variables, followed by a list of their user-missing
values in parentheses.  Up to three discrete values may be given, or,
for numeric variables only, a range of values optionally accompanied by
a single discrete value.  Ranges may be open-ended on one end, indicated
through the use of the keyword 'LO' or 'LOWEST' or 'HI' or 'HIGHEST'.

   The 'MISSING VALUES' command takes effect immediately.  It is not
affected by conditional and looping constructs such as 'DO IF' or
'LOOP'.


File: pspp.info,  Node: MODIFY VARS,  Next: MRSETS,  Prev: MISSING VALUES,  Up: Variable Attributes

11.7 MODIFY VARS
================

     MODIFY VARS
             /REORDER={FORWARD,BACKWARD} {POSITIONAL,ALPHA} (VAR_LIST)...
             /RENAME=(OLD_NAMES=NEW_NAMES)...
             /{DROP,KEEP}=VAR_LIST
             /MAP

   'MODIFY VARS' reorders, renames, and deletes variables in the active
dataset.

   At least one subcommand must be specified, and no subcommand may be
specified more than once.  'DROP' and 'KEEP' may not both be specified.

   The 'REORDER' subcommand changes the order of variables in the active
dataset.  Specify one or more lists of variable names in parentheses.
By default, each list of variables is rearranged into the specified
order.  To put the variables into the reverse of the specified order,
put keyword 'BACKWARD' before the parentheses.  To put them into
alphabetical order in the dictionary, specify keyword 'ALPHA' before the
parentheses.  'BACKWARD' and 'ALPHA' may also be combined.

   To rename variables in the active dataset, specify 'RENAME', an
equals sign ('='), and lists of the old variable names and new variable
names separated by another equals sign within parentheses.  There must
be the same number of old and new variable names.  Each old variable is
renamed to the corresponding new variable name.  Multiple parenthesized
groups of variables may be specified.

   The 'DROP' subcommand deletes a specified list of variables from the
active dataset.

   The 'KEEP' subcommand keeps the specified list of variables in the
active dataset.  Any unlisted variables are deleted from the active
dataset.

   'MAP' is currently ignored.

   If either 'DROP' or 'KEEP' is specified, the data is read; otherwise
it is not.

   'MODIFY VARS' may not be specified following 'TEMPORARY' (*note
TEMPORARY::).


File: pspp.info,  Node: MRSETS,  Next: NUMERIC,  Prev: MODIFY VARS,  Up: Variable Attributes

11.8 MRSETS
===========

     MRSETS
         /MDGROUP NAME=NAME VARIABLES=VAR_LIST VALUE=VALUE
          [CATEGORYLABELS={VARLABELS,COUNTEDVALUES}]
          [{LABEL='LABEL',LABELSOURCE=VARLABEL}]

         /MCGROUP NAME=NAME VARIABLES=VAR_LIST [LABEL='LABEL']

         /DELETE NAME={[NAMES],ALL}

         /DISPLAY NAME={[NAMES],ALL}

   'MRSETS' creates, modifies, deletes, and displays multiple response
sets.  A multiple response set is a set of variables that represent
multiple responses to a single survey question in one of the two
following ways:

   * A "multiple dichotomy set" is analogous to a survey question with a
     set of checkboxes.  Each variable in the set is treated in a
     Boolean fashion: one value (the "counted value") means that the box
     was checked, and any other value means that it was not.

   * A "multiple category set" represents a survey question where the
     respondent is instructed to list up to N choices.  Each variable
     represents one of the responses.

   Any number of subcommands may be specified in any order.

   The 'MDGROUP' subcommand creates a new multiple dichotomy set or
replaces an existing multiple response set.  The 'NAME', 'VARIABLES',
and 'VALUE' specifications are required.  The others are optional:

   * NAME specifies the name used in syntax for the new multiple
     dichotomy set.  The name must begin with '$'; it must otherwise
     follow the rules for identifiers (*note Tokens::).

   * 'VARIABLES' specifies the variables that belong to the set.  At
     least two variables must be specified.  The variables must be all
     string or all numeric.

   * 'VALUE' specifies the counted value.  If the variables are numeric,
     the value must be an integer.  If the variables are strings, then
     the value must be a string that is no longer than the shortest of
     the variables in the set (ignoring trailing spaces).

   * 'CATEGORYLABELS' optionally specifies the source of the labels for
     each category in the set:

        - 'VARLABELS', the default, uses variable labels or, for
          variables without variable labels, variable names.  PSPP warns
          if two variables have the same variable label, since these
          categories cannot be distinguished in output.

        - 'COUNTEDVALUES' instead uses each variable's value label for
          the counted value.  PSPP warns if two variables have the same
          value label for the counted value or if one of the variables
          lacks a value label, since such categories cannot be
          distinguished in output.

   * 'LABEL' optionally specifies a label for the multiple response set.
     If neither 'LABEL' nor 'LABELSOURCE=VARLABEL' is specified, the set
     is unlabeled.

   * 'LABELSOURCE=VARLABEL' draws the multiple response set's label from
     the first variable label among the variables in the set; if none of
     the variables has a label, the name of the first variable is used.
     'LABELSOURCE=VARLABEL' must be used with
     'CATEGORYLABELS=COUNTEDVALUES'.  It is mutually exclusive with
     'LABEL'.

   The 'MCGROUP' subcommand creates a new multiple category set or
replaces an existing multiple response set.  The 'NAME' and 'VARIABLES'
specifications are required, and 'LABEL' is optional.  Their meanings
are as described above in 'MDGROUP'.  PSPP warns if two variables in the
set have different value labels for a single value, since each of the
variables in the set should have the same possible categories.

   The 'DELETE' subcommand deletes multiple response groups.  A list of
groups may be named within a set of required square brackets, or ALL may
be used to delete all groups.

   The 'DISPLAY' subcommand displays information about defined multiple
response sets.  Its syntax is the same as the 'DELETE' subcommand.

   Multiple response sets are saved to and read from system files by,
e.g., the 'SAVE' and 'GET' command.  Otherwise, multiple response sets
are currently used only by third party software.


File: pspp.info,  Node: NUMERIC,  Next: PRINT FORMATS,  Prev: MRSETS,  Up: Variable Attributes

11.9 NUMERIC
============

     NUMERIC /VAR_LIST [(FMT_SPEC)].

   'NUMERIC' explicitly declares new numeric variables, optionally
setting their output formats.

   Specify a slash ('/'), followed by the names of the new numeric
variables.  If you wish to set their output formats, follow their names
by an output format specification in parentheses (*note Input and Output
Formats::); otherwise, the default is F8.2.

   Variables created with 'NUMERIC' are initialized to the
system-missing value.


File: pspp.info,  Node: PRINT FORMATS,  Next: RENAME VARIABLES,  Prev: NUMERIC,  Up: Variable Attributes

11.10 PRINT FORMATS
===================

     PRINT FORMATS VAR_LIST (FMT_SPEC) [VAR_LIST (FMT_SPEC)]....

   'PRINT FORMATS' sets the print formats for the specified variables to
the specified format specification.

   Its syntax is identical to that of 'FORMATS' (*note FORMATS::), but
'PRINT FORMATS' sets only print formats, not write formats.


File: pspp.info,  Node: RENAME VARIABLES,  Next: SORT VARIABLES,  Prev: PRINT FORMATS,  Up: Variable Attributes

11.11 RENAME VARIABLES
======================

     RENAME VARIABLES (OLD_NAMES=NEW_NAMES)... .

   'RENAME VARIABLES' changes the names of variables in the active
dataset.  Specify lists of the old variable names and new variable
names, separated by an equals sign ('='), within parentheses.  There
must be the same number of old and new variable names.  Each old
variable is renamed to the corresponding new variable name.  Multiple
parenthesized groups of variables may be specified.  When the old and
new variable names contain only a single variable name, the parentheses
are optional.

   'RENAME VARIABLES' takes effect immediately.  It does not cause the
data to be read.

   'RENAME VARIABLES' may not be specified following 'TEMPORARY' (*note
TEMPORARY::).


File: pspp.info,  Node: SORT VARIABLES,  Next: VALUE LABELS,  Prev: RENAME VARIABLES,  Up: Variable Attributes

11.12 SORT VARIABLES
====================

     SORT VARIABLES [BY]
         (NAME | TYPE | FORMAT | LABEL | VALUES | MISSING | MEASURE
          | ROLE | COLUMNS | ALIGNMENT | ATTRIBUTE NAME)
         [(D)].

   'SORT VARIABLES' reorders the variables in the active dataset.  The
main specification is one of the following identifiers, which determines
how the variables are sorted:

NAME
     Sorts the variables according to their names, in a case-insensitive
     fashion.  However, when variable names differ only in a number at
     the end, they are sorted numerically.  For example, 'VAR5' is
     sorted before 'VAR400' even though '4' precedes '5'.

TYPE
     Sorts numeric variables before string variables, and shorter string
     variables before longer ones.

FORMAT
     Groups variables by print format; within a format, sorts narrower
     formats before wider ones; with the same format and width, sorts
     fewer decimal places before more decimal places.  *Note FORMATS::.

LABEL
     Sorts variables without a variable label before those with one.
     *Note VARIABLE LABELS::.

VALUES
     Sorts variables without value labels before those with some.  *Note
     VALUE LABELS::.

MISSING
     Sorts variables without missing values before those with some.
     *Note MISSING VALUES::.

MEASURE
     Sorts nominal variables first, followed by ordinal variables,
     followed by scale variables.  *Note VARIABLE LEVEL::.

ROLE
     Groups variables according to their role.  *Note VARIABLE ROLE::.

COLUMNS
     Sorts variables in ascending display width.  *Note VARIABLE
     WIDTH::.

ALIGNMENT
     Sorts variables according to their alignment, first left-aligned,
     then right-aligned, then centered.  *Note VARIABLE ALIGNMENT::.

ATTRIBUTE NAME
     Sorts variables according to the first value of their NAME
     attribute.  Variables without attribute are sorted first.  *Note
     VARIABLE ATTRIBUTE::.

   Only one sort criterion can be specified.  The sort is "stable," so
to sort on multiple criteria one may perform multiple sorts.  For
example, the following will sort primarily based on alignment, with
variables that have the same alignment ordered based on display width:

     SORT VARIABLES BY COLUMNS.
     SORT VARIABLES BY ALIGNMENT.

   Specify '(D)' to reverse the sort order.


File: pspp.info,  Node: VALUE LABELS,  Next: STRING,  Prev: SORT VARIABLES,  Up: Variable Attributes

11.13 VALUE LABELS
==================

     VALUE LABELS
             /VAR_LIST VALUE 'LABEL' [VALUE 'LABEL']...

   'VALUE LABELS' allows values of variables to be associated with
labels.  In this way, a short value can stand for a longer, more
descriptive label.

   Both numeric and string variables can be given labels.  For string
variables, the values are case-sensitive, so that, for example, a
capitalized value and its lowercase variant would have to be labeled
separately if both are present in the data.

   To set up value labels for one or more variables, specify the
variable names after a slash ('/'), followed by a list of values and
their associated labels, separated by spaces.

   Value labels in output are normally broken into lines automatically.
Put '\n' in a label string to force a line break at that point.  The
label may still be broken into lines at additional points.

   Before 'VALUE LABELS' is executed, any existing value labels are
cleared from the variables specified.  Use 'ADD VALUE LABELS' (*note ADD
VALUE LABELS::) to add value labels without clearing those already
present.


File: pspp.info,  Node: STRING,  Next: VARIABLE ATTRIBUTE,  Prev: VALUE LABELS,  Up: Variable Attributes

11.14 STRING
============

     STRING VAR_LIST (FMT_SPEC) [/VAR_LIST (FMT_SPEC)] [...].

   'STRING' creates new string variables for use in transformations.

   Specify a list of names for the variable you want to create, followed
by the desired output format specification in parentheses (*note Input
and Output Formats::).  Variable widths are implicitly derived from the
specified output formats.  The created variables will be initialized to
spaces.

   If you want to create several variables with distinct output formats,
you can either use two or more separate 'STRING' commands, or you can
specify further variable list and format specification pairs, each
separated from the previous by a slash ('/').

   The following example is one way to create three string variables;
Two of the variables have format A24 and the other A80:
     STRING firstname lastname (A24) / address (A80).

Here is another way to achieve the same result:
     STRING firstname lastname (A24).
     STRING address (A80).

... and here is yet another way:

     STRING firstname (A24).
     STRING lastname (A24).
     STRING address (A80).


File: pspp.info,  Node: VARIABLE ATTRIBUTE,  Next: VARIABLE LABELS,  Prev: STRING,  Up: Variable Attributes

11.15 VARIABLE ATTRIBUTE
========================

     VARIABLE ATTRIBUTE
              VARIABLES=VAR_LIST
              ATTRIBUTE=NAME('VALUE') [NAME('VALUE')]...
              ATTRIBUTE=NAME[INDEX]('VALUE') [NAME[INDEX]('VALUE')]...
              DELETE=NAME [NAME]...
              DELETE=NAME[INDEX] [NAME[INDEX]]...

   'VARIABLE ATTRIBUTE' adds, modifies, or removes user-defined
attributes associated with variables in the active dataset.  Custom
variable attributes are not interpreted by PSPP, but they are saved as
part of system files and may be used by other software that reads them.

   The required 'VARIABLES' subcommand must come first.  Specify the
variables to which the following 'ATTRIBUTE' or 'DELETE' subcommand
should apply.

   Use the 'ATTRIBUTE' subcommand to add or modify custom variable
attributes.  Specify the name of the attribute as an identifier (*note
Tokens::), followed by the desired value, in parentheses, as a quoted
string.  The specified attributes are then added or modified in the
variables specified on 'VARIABLES'.  Attribute names that begin with '$'
are reserved for PSPP's internal use, and attribute names that begin
with '@' or '$@' are not displayed by most PSPP commands that display
other attributes.  Other attribute names are not treated specially.

   Attributes may also be organized into arrays.  To assign to an array
element, add an integer array index enclosed in square brackets ('[' and
']') between the attribute name and value.  Array indexes start at 1,
not 0.  An attribute array that has a single element (number 1) is not
distinguished from a non-array attribute.

   Use the 'DELETE' subcommand to delete an attribute from the variable
specified on 'VARIABLES'.  Specify an attribute name by itself to delete
an entire attribute, including all array elements for attribute arrays.
Specify an attribute name followed by an array index in square brackets
to delete a single element of an attribute array.  In the latter case,
all the array elements numbered higher than the deleted element are
shifted down, filling the vacated position.

   To associate custom attributes with the entire active dataset,
instead of with particular variables, use 'DATAFILE ATTRIBUTE' (*note
DATAFILE ATTRIBUTE::) instead.

   'VARIABLE ATTRIBUTE' takes effect immediately.  It is not affected by
conditional and looping structures such as 'DO IF' or 'LOOP'.


File: pspp.info,  Node: VARIABLE LABELS,  Next: VARIABLE ALIGNMENT,  Prev: VARIABLE ATTRIBUTE,  Up: Variable Attributes

11.16 VARIABLE LABELS
=====================

     VARIABLE LABELS
             VAR_LIST 'VAR_LABEL'
             [ /VAR_LIST 'VAR_LABEL']
             .
             .
             .
             [ /VAR_LIST 'VAR_LABEL']

   'VARIABLE LABELS' associates explanatory names with variables.  This
name, called a "variable label", is displayed by statistical procedures.

   To assign a variable label to a group of variables, specify a list of
variable names and the variable label as a string.  To assign different
labels to different variables in the same command, precede the
subsequent variable list with a slash ('/').


File: pspp.info,  Node: VARIABLE ALIGNMENT,  Next: VARIABLE WIDTH,  Prev: VARIABLE LABELS,  Up: Variable Attributes

11.17 VARIABLE ALIGNMENT
========================

     VARIABLE ALIGNMENT
             VAR_LIST ( LEFT | RIGHT | CENTER )
             [ /VAR_LIST ( LEFT | RIGHT | CENTER ) ]
             .
             .
             .
             [ /VAR_LIST ( LEFT | RIGHT | CENTER ) ]

   'VARIABLE ALIGNMENT' sets the alignment of variables for display
editing purposes.  This only has effect for third party software.  It
does not affect the display of variables in the PSPP output.


File: pspp.info,  Node: VARIABLE WIDTH,  Next: VARIABLE LEVEL,  Prev: VARIABLE ALIGNMENT,  Up: Variable Attributes

11.18 VARIABLE WIDTH
====================

     VARIABLE WIDTH
             VAR_LIST (width)
             [ /VAR_LIST (width) ]
             .
             .
             .
             [ /VAR_LIST (width) ]

   'VARIABLE WIDTH' sets the column width of variables for display
editing purposes.  This only affects third party software.  It does not
affect the display of variables in the PSPP output.


File: pspp.info,  Node: VARIABLE LEVEL,  Next: VARIABLE ROLE,  Prev: VARIABLE WIDTH,  Up: Variable Attributes

11.19 VARIABLE LEVEL
====================

     VARIABLE LEVEL
             VAR_LIST ( SCALE | NOMINAL | ORDINAL )
             [ /VAR_LIST ( SCALE | NOMINAL | ORDINAL ) ]
             .
             .
             .
             [ /VAR_LIST ( SCALE | NOMINAL | ORDINAL ) ]

   'VARIABLE LEVEL' sets the measurement level of variables.  Currently,
this has no effect except for certain third party software.


File: pspp.info,  Node: VARIABLE ROLE,  Next: VECTOR,  Prev: VARIABLE LEVEL,  Up: Variable Attributes

11.20 VARIABLE ROLE
===================

     VARIABLE ROLE
             /ROLE VAR_LIST
             [/ROLE VAR_LIST]...

   'VARIABLE ROLE' sets the intended role of a variable for use in
dialog boxes in graphical user interfaces.  Each ROLE specifies one of
the following roles for the variables that follow it:

'INPUT'
     An input variable, such as an independent variable.

'TARGET'
     An output variable, such as an dependent variable.

'BOTH'
     A variable used for input and output.

'NONE'
     No role assigned.  (This is a variable's default role.)

'PARTITION'
     Used to break the data into groups for testing.

'SPLIT'
     No meaning except for certain third party software.  (This role's
     meaning is unrelated to 'SPLIT FILE'.)

   The PSPPIRE GUI does not yet use variable roles as intended.


File: pspp.info,  Node: VECTOR,  Next: WRITE FORMATS,  Prev: VARIABLE ROLE,  Up: Variable Attributes

11.21 VECTOR
============

     Two possible syntaxes:
             VECTOR VEC_NAME=VAR_LIST.
             VECTOR VEC_NAME_LIST(COUNT [FORMAT]).

   'VECTOR' allows a group of variables to be accessed as if they were
consecutive members of an array with a vector(index) notation.

   To make a vector out of a set of existing variables, specify a name
for the vector followed by an equals sign ('=') and the variables to put
in the vector.  All the variables in the vector must be the same type.
String variables in a vector must all have the same width.

   To make a vector and create variables at the same time, specify one
or more vector names followed by a count in parentheses.  This will
cause variables named 'VEC1' through 'VECCOUNT' to be created as numeric
variables.  By default, the new variables have print and write format
F8.2, but an alternate format may be specified inside the parentheses
before or after the count and separated from it by white space or a
comma.  Variable names including numeric suffixes may not exceed 64
characters in length, and none of the variables may exist prior to
'VECTOR'.

   Vectors created with 'VECTOR' disappear after any procedure or
procedure-like command is executed.  The variables contained in the
vectors remain, unless they are scratch variables (*note Scratch
Variables::).

   Variables within a vector may be referenced in expressions using
'vector(index)' syntax.


File: pspp.info,  Node: WRITE FORMATS,  Prev: VECTOR,  Up: Variable Attributes

11.22 WRITE FORMATS
===================

     WRITE FORMATS VAR_LIST (FMT_SPEC) [VAR_LIST (FMT_SPEC)]....

   'WRITE FORMATS' sets the write formats for the specified variables to
the specified format specification.  Its syntax is identical to that of
'FORMATS' (*note FORMATS::), but 'WRITE FORMATS' sets only write
formats, not print formats.


File: pspp.info,  Node: Data Manipulation,  Next: Data Selection,  Prev: Variable Attributes,  Up: Top

12 Data transformations
***********************

The PSPP procedures examined in this chapter manipulate data and prepare
the active dataset for later analyses.  They do not produce output, as a
rule.

* Menu:

* AGGREGATE::                   Summarize multiple cases into a single case.
* AUTORECODE::                  Automatic recoding of variables.
* COMPUTE::                     Assigning a variable a calculated value.
* COUNT::                       Counting variables with particular values.
* FLIP::                        Exchange variables with cases.
* IF::                          Conditionally assigning a calculated value.
* RECODE::                      Mapping values from one set to another.
* SORT CASES::                  Sort the active dataset.


File: pspp.info,  Node: AGGREGATE,  Next: AUTORECODE,  Up: Data Manipulation

12.1 AGGREGATE
==============

     AGGREGATE
             OUTFILE={*,'FILE_NAME',FILE_HANDLE} [MODE={REPLACE, ADDVARIABLES}]
             /PRESORTED
             /DOCUMENT
             /MISSING=COLUMNWISE
             /BREAK=VAR_LIST
             /DEST_VAR['LABEL']...=AGR_FUNC(SRC_VARS, ARGS...)...

   'AGGREGATE' summarizes groups of cases into single cases.  Cases are
divided into groups that have the same values for one or more variables
called "break variables".  Several functions are available for
summarizing case contents.

   The 'OUTFILE' subcommand is required and must appear first.  Specify
a system file or portable file by file name or file handle (*note File
Handles::), or a dataset by its name (*note Datasets::).  The aggregated
cases are written to this file.  If '*' is specified, then the
aggregated cases replace the active dataset's data.  Use of 'OUTFILE' to
write a portable file is a PSPP extension.

   If 'OUTFILE=*' is given, then the subcommand 'MODE' may also be
specified.  The mode subcommand has two possible values: 'ADDVARIABLES'
or 'REPLACE'.  In 'REPLACE' mode, the entire active dataset is replaced
by a new dataset which contains just the break variables and the
destination varibles.  In this mode, the new file will contain as many
cases as there are unique combinations of the break variables.  In
'ADDVARIABLES' mode, the destination variables will be appended to the
existing active dataset.  Cases which have identical combinations of
values in their break variables, will receive identical values for the
destination variables.  The number of cases in the active dataset will
remain unchanged.  Note that if 'ADDVARIABLES' is specified, then the
data _must_ be sorted on the break variables.

   By default, the active dataset will be sorted based on the break
variables before aggregation takes place.  If the active dataset is
already sorted or otherwise grouped in terms of the break variables,
specify 'PRESORTED' to save time.  'PRESORTED' is assumed if
'MODE=ADDVARIABLES' is used.

   Specify 'DOCUMENT' to copy the documents from the active dataset into
the aggregate file (*note DOCUMENT::).  Otherwise, the aggregate file
will not contain any documents, even if the aggregate file replaces the
active dataset.

   Normally, only a single case (for 'SD' and 'SD'., two cases) need be
non-missing in each group for the aggregate variable to be non-missing.
Specifying '/MISSING=COLUMNWISE' inverts this behavior, so that the
aggregate variable becomes missing if any aggregated value is missing.

   If 'PRESORTED', 'DOCUMENT', or 'MISSING' are specified, they must
appear between 'OUTFILE' and 'BREAK'.

   At least one break variable must be specified on 'BREAK', a required
subcommand.  The values of these variables are used to divide the active
dataset into groups to be summarized.  In addition, at least one
DEST_VAR must be specified.

   One or more sets of aggregation variables must be specified.  Each
set comprises a list of aggregation variables, an equals sign ('='), the
name of an aggregation function (see the list below), and a list of
source variables in parentheses.  Some aggregation functions expect
additional arguments following the source variable names.

   Aggregation variables typically are created with no variable label,
value labels, or missing values.  Their default print and write formats
depend on the aggregation function used, with details given in the table
below.  A variable label for an aggregation variable may be specified
just after the variable's name in the aggregation variable list.

   Each set must have exactly as many source variables as aggregation
variables.  Each aggregation variable receives the results of applying
the specified aggregation function to the corresponding source variable.
The 'MEAN', 'MEDIAN', 'SD', and 'SUM' aggregation functions may only be
applied to numeric variables.  All the rest may be applied to numeric
and string variables.

   The available aggregation functions are as follows:

'FGT(VAR_NAME, VALUE)'
     Fraction of values greater than the specified constant.  The
     default format is F5.3.

'FIN(VAR_NAME, LOW, HIGH)'
     Fraction of values within the specified inclusive range of
     constants.  The default format is F5.3.

'FLT(VAR_NAME, VALUE)'
     Fraction of values less than the specified constant.  The default
     format is F5.3.

'FIRST(VAR_NAME)'
     First non-missing value in break group.  The aggregation variable
     receives the complete dictionary information from the source
     variable.  The sort performed by 'AGGREGATE' (and by 'SORT CASES')
     is stable, so that the first case with particular values for the
     break variables before sorting will also be the first case in that
     break group after sorting.

'FOUT(VAR_NAME, LOW, HIGH)'
     Fraction of values strictly outside the specified range of
     constants.  The default format is F5.3.

'LAST(VAR_NAME)'
     Last non-missing value in break group.  The aggregation variable
     receives the complete dictionary information from the source
     variable.  The sort performed by 'AGGREGATE' (and by 'SORT CASES')
     is stable, so that the last case with particular values for the
     break variables before sorting will also be the last case in that
     break group after sorting.

'MAX(VAR_NAME)'
     Maximum value.  The aggregation variable receives the complete
     dictionary information from the source variable.

'MEAN(VAR_NAME)'
     Arithmetic mean.  Limited to numeric values.  The default format is
     F8.2.

'MEDIAN(VAR_NAME)'
     The median value.  Limited to numeric values.  The default format
     is F8.2.

'MIN(VAR_NAME)'
     Minimum value.  The aggregation variable receives the complete
     dictionary information from the source variable.

'N(VAR_NAME)'
     Number of non-missing values.  The default format is F7.0 if
     weighting is not enabled, F8.2 if it is (*note WEIGHT::).

'N'
     Number of cases aggregated to form this group.  The default format
     is F7.0 if weighting is not enabled, F8.2 if it is (*note
     WEIGHT::).

'NMISS(VAR_NAME)'
     Number of missing values.  The default format is F7.0 if weighting
     is not enabled, F8.2 if it is (*note WEIGHT::).

'NU(VAR_NAME)'
     Number of non-missing values.  Each case is considered to have a
     weight of 1, regardless of the current weighting variable (*note
     WEIGHT::).  The default format is F7.0.

'NU'
     Number of cases aggregated to form this group.  Each case is
     considered to have a weight of 1, regardless of the current
     weighting variable.  The default format is F7.0.

'NUMISS(VAR_NAME)'
     Number of missing values.  Each case is considered to have a weight
     of 1, regardless of the current weighting variable.  The default
     format is F7.0.

'PGT(VAR_NAME, VALUE)'
     Percentage between 0 and 100 of values greater than the specified
     constant.  The default format is F5.1.

'PIN(VAR_NAME, LOW, HIGH)'
     Percentage of values within the specified inclusive range of
     constants.  The default format is F5.1.

'PLT(VAR_NAME, VALUE)'
     Percentage of values less than the specified constant.  The default
     format is F5.1.

'POUT(VAR_NAME, LOW, HIGH)'
     Percentage of values strictly outside the specified range of
     constants.  The default format is F5.1.

'SD(VAR_NAME)'
     Standard deviation of the mean.  Limited to numeric values.  The
     default format is F8.2.

'SUM(VAR_NAME)'
     Sum.  Limited to numeric values.  The default format is F8.2.

   Aggregation functions compare string values in terms of internal
character codes.  On most modern computers, this is ASCII or a superset
thereof.

   The aggregation functions listed above exclude all user-missing
values from calculations.  To include user-missing values, insert a
period ('.') at the end of the function name.  (e.g. 'SUM.').  (Be aware
that specifying such a function as the last token on a line will cause
the period to be interpreted as the end of the command.)

   'AGGREGATE' both ignores and cancels the current 'SPLIT FILE'
settings (*note SPLIT FILE::).


File: pspp.info,  Node: AUTORECODE,  Next: COMPUTE,  Prev: AGGREGATE,  Up: Data Manipulation

12.2 AUTORECODE
===============

     AUTORECODE VARIABLES=SRC_VARS INTO DEST_VARS
             [ /DESCENDING ]
             [ /PRINT ]
             [ /GROUP ]
             [ /BLANK = {VALID, MISSING} ]

   The 'AUTORECODE' procedure considers the N values that a variable
takes on and maps them onto values 1...N on a new numeric variable.

   Subcommand 'VARIABLES' is the only required subcommand and must come
first.  Specify 'VARIABLES', an equals sign ('='), a list of source
variables, 'INTO', and a list of target variables.  There must the same
number of source and target variables.  The target variables must not
already exist.

   By default, increasing values of a source variable (for a string,
this is based on character code comparisons) are recoded to increasing
values of its target variable.  To cause increasing values of a source
variable to be recoded to decreasing values of its target variable (N
down to 1), specify 'DESCENDING'.

   'PRINT' is currently ignored.

   The 'GROUP' subcommand is relevant only if more than one variable is
to be recoded.  It causes a single mapping between source and target
values to be used, instead of one map per variable.

   If '/BLANK=MISSING' is given, then string variables which contain
only whitespace are recoded as SYSMIS. If '/BLANK=VALID' is given then
they will be allocated a value like any other.  '/BLANK' is not relevant
to numeric values.  '/BLANK=VALID' is the default.

   'AUTORECODE' is a procedure.  It causes the data to be read.


File: pspp.info,  Node: COMPUTE,  Next: COUNT,  Prev: AUTORECODE,  Up: Data Manipulation

12.3 COMPUTE
============

     COMPUTE VARIABLE = EXPRESSION.
   or
     COMPUTE vector(INDEX) = EXPRESSION.

   'COMPUTE' assigns the value of an expression to a target variable.
For each case, the expression is evaluated and its value assigned to the
target variable.  Numeric and string variables may be assigned.  When a
string expression's width differs from the target variable's width, the
string result of the expression is truncated or padded with spaces on
the right as necessary.  The expression and variable types must match.

   For numeric variables only, the target variable need not already
exist.  Numeric variables created by 'COMPUTE' are assigned an 'F8.2'
output format.  String variables must be declared before they can be
used as targets for 'COMPUTE'.

   The target variable may be specified as an element of a vector (*note
VECTOR::).  In this case, an expression INDEX must be specified in
parentheses following the vector name.  The expression INDEX must
evaluate to a numeric value that, after rounding down to the nearest
integer, is a valid index for the named vector.

   Using 'COMPUTE' to assign to a variable specified on 'LEAVE' (*note
LEAVE::) resets the variable's left state.  Therefore, 'LEAVE' should be
specified following 'COMPUTE', not before.

   'COMPUTE' is a transformation.  It does not cause the active dataset
to be read.

   When 'COMPUTE' is specified following 'TEMPORARY' (*note
TEMPORARY::), the 'LAG' function may not be used (*note LAG::).

